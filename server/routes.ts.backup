import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { db } from "./db";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { z } from "zod";
import fetch from "node-fetch";
import {
  loginSchema,
  registerSchema,
  adminLoginSchema,
  insertGameSchema,
  insertDepositSchema,
  insertWithdrawalSchema,
  users,
  wallets,
  games,
  gameMinigames,
  gamePremios,
  deposits,
  withdrawals,
  supportChats,
  supportMessages,
  referrals,
  referralEarnings,
  gameProbabilities,
} from "@shared/schema";
import { randomUUID } from "crypto";
import { eq, desc, asc } from "drizzle-orm";

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
const IRONPAY_API_KEY = process.env.IRONPAY_API_KEY || "ssbeBmAozr5R4D0eR5yEzyPNfImP32Tvhh9cdjY8e3OvUgZ1EVf0FJLlc8ff";
const IRONPAY_API_URL = "https://api.ironpayapp.com.br/api";

// Game configurations
const GAME_CONFIGS = {
  pix_na_conta: { cost: "5.00", prizes: [5, 10, 25, 50], odds: 0.3 },
  sonho_consumo: { cost: "10.00", prizes: [10, 25, 50, 100], odds: 0.25 },
  me_mimei: { cost: "2.00", prizes: [2, 5, 10, 20], odds: 0.4 },
  super_premios: { cost: "50.00", prizes: [50, 100, 500, 1000], odds: 0.1 },
};

// Middleware to verify JWT token
const authenticateToken = async (req: any, res: any, next: any) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ message: "Token de acesso requerido" });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as { userId: number };
    req.userId = decoded.userId;
    next();
  } catch (error) {
    return res.status(403).json({ message: "Token inv√°lido" });
  }
};

// Middleware to allow both authenticated users and welcome users
const authenticateOptionalWithWelcome = async (req: any, res: any, next: any) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (token) {
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as { userId: number };
      req.userId = decoded.userId;
      next();
    } catch (error) {
      return res.status(403).json({ message: "Token inv√°lido" });
    }
  } else if (req.body.isWelcomeUser && req.body.freePlay) {
    // Allow non-authenticated users with welcome bonus
    req.userId = null;
    req.isWelcomeUser = true;
    next();
  } else {
    return res.status(401).json({ message: "Token de acesso requerido" });
  }
};

// Middleware to verify admin session
const authenticateAdmin = async (req: any, res: any, next: any) => {
  const sessionId = req.headers.authorization?.split(" ")[1];

  if (!sessionId) {
    return res.status(401).json({ message: "Sess√£o de admin requerida" });
  }

  try {
    const session = await storage.getAdminSession(sessionId);
    if (!session) {
      return res.status(403).json({ message: "Sess√£o inv√°lida ou expirada" });
    }
    req.adminSession = session;
    next();
  } catch (error) {
    return res.status(500).json({ message: "Erro ao verificar sess√£o" });
  }
};

// Checkoutinho API integration
const createPixPayment = async (amount: number, customerData: any) => {
  const apiUrl = `${IRONPAY_API_URL}/public/v1/transactions?api_token=${IRONPAY_API_KEY}`;

  const payload = {
    amount: amount * 100, // Convert to cents
    offer_hash: "raspadinha", // Generic offer hash
    payment_method: "pix",
    customer: {
      name: "Cliente Teste",
      email: "cliente@teste.com",
      phone_number: "11999999999",
      document: "073.255.036-01", // Fixed CPF with dots and dash
    },
    cart: [
      {
        product_hash: "venda",
        title: "Venda",
        price: amount * 100,
        quantity: 1,
        operation_type: 1,
        tangible: false,
        product_id: 1,
        offer_id: 1
      }
    ],
    installments: 1,
    expire_in_days: 1,
    transaction_origin: "api",
    postback_url: `${process.env.APP_URL || 'https://raspadinhadasorte.site'}/api/webhook/pix`
  };

  console.log("Creating IronPay PIX payment:", { url: apiUrl, payload });

  try {
    // Dynamic import for ESM module
    const { default: fetch } = await import("node-fetch");

    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    const responseText = await response.text();
    console.log("IronPay API Response:", {
      status: response.status,
      body: responseText,
    });

    if (!response.ok) {
      throw new Error(
        `Payment API error: ${response.status} - ${responseText}`,
      );
    }

    const data = JSON.parse(responseText);
    
    // Map IronPay response to our expected format
    return {
      pixCode: data.pix?.pix_qr_code || data.pix_qr_code || data.hash,
      transactionId: data.hash || data.id || data.transaction_id,
      qrCode: data.pix?.pix_qr_code || data.pix_qr_code || data.qr_code,
      amount: amount
    };
  } catch (error) {
    console.error("IronPay PIX payment error:", error);
    throw error;
  }
};

const verifyPixPayment = async (transactionId: string) => {
  try {
    // Dynamic import for ESM module
    const { default: fetch } = await import("node-fetch");

    const response = await fetch(
      `${IRONPAY_API_URL}/public/v1/transactions/${transactionId}?api_token=${IRONPAY_API_KEY}`,
      {
        method: "GET",
        headers: { 
          "Accept": "application/json" 
        },
      },
    );

    const data = await response.json();
    console.log("IronPay verification response:", data);

    // Map IronPay response to our expected format
    if (data && data.status) {
      return {
        status: data.status === "paid" || data.status === "approved" ? "completed" : "pending"
      };
    }

    return { status: "pending" };
  } catch (error) {
    console.error("IronPay PIX verification error:", error);
    throw error;
  }
};

// In-memory game state storage (in production, use Redis or database)
const activeGames = new Map<string, any>();

// Helper function to calculate total probability
// Function removed - no longer needed with new independent probability system

// Temporary storage for SORTE coupon registrations  
const sorteCouponUsers = new Set<number>();

// In-memory store for user claimed rewards
const userClaimedRewards = new Map<number, number[]>();

// In-memory store for daily chest claims
const userDailyChestClaims = new Map<number, Date>();

// Clean up old games periodically
setInterval(
  () => {
    const now = Date.now();
    const GAME_EXPIRY = 30 * 60 * 1000; // 30 minutes

    for (const [gameId, game] of activeGames.entries()) {
      if (now - game.createdAt.getTime() > GAME_EXPIRY) {
        activeGames.delete(gameId);
      }
    }
  },
  5 * 60 * 1000,
); // Clean up every 5 minutes

// Helper function to validate referral when deposit is made
const validateReferralOnDeposit = async (userId: number, depositAmount: string) => {
  try {
    // Check if deposit meets minimum requirement (R$15)
    if (parseFloat(depositAmount) < 15) {
      return;
    }
    
    // Check if user was referred
    const referral = await storage.getReferralsByReferred(userId);
    if (!referral || referral.status === 'validated') {
      return;
    }
    
    // Validate the referral
    await storage.validateReferral(referral.id);
    
    // Calculate commission (10% of deposit)
    const commission = (parseFloat(depositAmount) * 0.10).toFixed(2);
    
    // Create referral earning for the referrer
    await storage.createReferralEarning({
      userId: referral.referrerId,
      referralId: referral.id,
      amount: commission
    });
  } catch (error) {
    console.error("Error validating referral on deposit:", error);
  }
};

// Helper function to process referral commission for all deposits
const processReferralCommission = async (userId: number, depositAmount: string) => {
  try {
    // Check if user was referred
    const referral = await storage.getReferralsByReferred(userId);
    if (!referral) {
      return;
    }
    
    // Get referred user info for transaction description
    const referredUser = await storage.getUser(userId);
    const referredName = referredUser?.name || 'Usu√°rio';
    
    // Calculate commission (10% of deposit)
    const commission = (parseFloat(depositAmount) * 0.10).toFixed(2);
    
    // Create referral earning for the referrer
    await storage.createReferralEarning({
      userId: referral.referrerId,
      referralId: referral.id,
      amount: commission
    });
    
    console.log(`Processed referral commission: R$${commission} for user ${referral.referrerId} from deposit of R$${depositAmount} by ${referredName}`);
  } catch (error) {
    console.error("Error processing referral commission:", error);
  }
};

// Game logic
const generateScratchResult = (gameType: keyof typeof GAME_CONFIGS) => {
  const config = GAME_CONFIGS[gameType];
  const symbols = ["üí∞", "üéØ", "üé≤", "üíé", "üçÄ", "‚≠ê", "üéÅ", "üî•"];

  const isWinner = Math.random() < config.odds;
  const grid = Array(9).fill(null);

  if (isWinner) {
    const winningSymbol = symbols[Math.floor(Math.random() * symbols.length)];
    const winningPositions = [0, 4, 8]; // Diagonal win

    winningPositions.forEach((pos) => {
      grid[pos] = winningSymbol;
    });

    // Fill remaining positions with random symbols
    grid.forEach((cell, index) => {
      if (cell === null) {
        grid[index] = symbols[Math.floor(Math.random() * symbols.length)];
      }
    });

    const prizeIndex = Math.floor(Math.random() * config.prizes.length);
    const prize = config.prizes[prizeIndex];

    return { grid, won: true, prize };
  } else {
    // Generate losing combination
    grid.forEach((_, index) => {
      grid[index] = symbols[Math.floor(Math.random() * symbols.length)];
    });

    // Ensure no winning combinations
    const symbolCounts: Record<string, number> = {};
    grid.forEach((symbol) => {
      symbolCounts[symbol] = (symbolCounts[symbol] || 0) + 1;
    });

    // If we accidentally created a winning combination, break it
    Object.keys(symbolCounts).forEach((symbol) => {
      if (symbolCounts[symbol] >= 3) {
        const positions = grid
          .map((s, i) => (s === symbol ? i : -1))
          .filter((i) => i !== -1);
        const differentSymbol = symbols.find((s) => s !== symbol);
        if (differentSymbol) {
          grid[positions[0]] = differentSymbol;
        }
      }
    });

    return { grid, won: false, prize: 0 };
  }
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth routes
  app.post("/api/auth/register", async (req, res) => {
    try {
      const validatedData = registerSchema.parse(req.body);
      const { referralCode, couponCode } = req.body; // Get referral and coupon codes from request

      // Check if user already exists by email
      const existingUserByEmail = await storage.getUserByEmail(validatedData.email);
      if (existingUserByEmail) {
        return res.status(400).json({ message: "Email j√° cadastrado" });
      }

      // Check if user already exists by phone
      const existingUserByPhone = await storage.getUserByPhone(validatedData.phone);
      if (existingUserByPhone) {
        return res.status(400).json({ message: "Telefone j√° cadastrado" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(validatedData.password, 10);

      // Create user
      const user = await storage.createUser({
        name: validatedData.name,
        email: validatedData.email,
        phone: validatedData.phone,
        password: hashedPassword,
      });

      // Track SORTE coupon usage
      if (couponCode && couponCode.toUpperCase() === 'SORTE') {
        sorteCouponUsers.add(user.id);
        console.log(`User ${user.id} registered with SORTE coupon`);
      }
      
      // Handle referral code if provided
      if (referralCode) {
        try {
          // Convert to uppercase to handle case-insensitive referral codes
          const normalizedCode = referralCode.toUpperCase();
          
          // Check if it's a system promo code
          if (normalizedCode === 'SORTE100' || normalizedCode === 'BONUS') {
            // System codes don't create referral relationships
            // Do nothing here
          } else {
            // Regular referral code
            const referrer = await storage.getUserByReferralCode(normalizedCode);
            if (referrer && referrer.id !== user.id) {
              // Create referral entry
              await storage.createReferral({
                referrerId: referrer.id,
                referredId: user.id,
                status: 'pending'
              });
            }
          }
        } catch (error) {
          console.error("Referral creation error:", error);
          // Don't fail registration if referral code is invalid
        }
      }

      // Generate JWT token
      const token = jwt.sign({ userId: user.id }, JWT_SECRET, {
        expiresIn: "7d",
      });

      res.json({
        message: "Usu√°rio criado com sucesso",
        token,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          phone: user.phone,
        },
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(400).json({ message: "Erro ao criar usu√°rio" });
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, phone, password } = req.body;

      // Validate input - require either email or phone
      if ((!email && !phone) || !password) {
        return res
          .status(400)
          .json({ message: "Email/telefone e senha s√£o obrigat√≥rios" });
      }

      // Find user by email or phone
      let user;
      if (email) {
        user = await storage.getUserByEmail(email);
      } else if (phone) {
        user = await storage.getUserByPhone(phone);
      }
      
      if (!user) {
        return res.status(400).json({ message: "Credenciais inv√°lidas" });
      }

      // Check password
      const isValid = await bcrypt.compare(password, user.password);
      if (!isValid) {
        return res.status(400).json({ message: "Credenciais inv√°lidas" });
      }

      // Get wallet balance
      const wallet = await storage.getWallet(user.id);

      // Generate JWT token
      const token = jwt.sign({ userId: user.id }, JWT_SECRET, {
        expiresIn: "7d",
      });

      res.json({
        message: "Login realizado com sucesso",
        token,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          phone: user.phone,
          balance: wallet?.balance || "0.00",
        },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(400).json({ message: "Erro ao fazer login" });
    }
  });

  app.post("/api/auth/forgot-password/verify", async (req, res) => {
    try {
      const { email, phone } = req.body;

      // Validate input
      if (!email || !phone) {
        return res
          .status(400)
          .json({ message: "Email e telefone s√£o obrigat√≥rios" });
      }

      // Clean phone number (remove formatting)
      const cleanPhone = phone.replace(/\D/g, '');

      // Find user by email AND phone
      const user = await storage.getUserByEmail(email);
      
      if (!user || user.phone !== cleanPhone) {
        return res.status(400).json({ message: "Dados n√£o encontrados" });
      }

      // Generate a temporary token for password reset (valid for 10 minutes)
      const resetToken = jwt.sign(
        { userId: user.id, type: 'password-reset' }, 
        JWT_SECRET, 
        { expiresIn: "10m" }
      );

      res.json({
        message: "Dados verificados com sucesso",
        resetToken,
        userId: user.id
      });
    } catch (error) {
      console.error("Forgot password verify error:", error);
      res.status(400).json({ message: "Erro ao verificar dados" });
    }
  });

  app.post("/api/auth/forgot-password/reset", async (req, res) => {
    try {
      const { resetToken, newPassword } = req.body;

      // Validate input
      if (!resetToken || !newPassword) {
        return res
          .status(400)
          .json({ message: "Token e nova senha s√£o obrigat√≥rios" });
      }

      // Verify reset token
      let decoded: any;
      try {
        decoded = jwt.verify(resetToken, JWT_SECRET);
        if (decoded.type !== 'password-reset') {
          throw new Error('Invalid token type');
        }
      } catch (error) {
        return res.status(400).json({ message: "Token inv√°lido ou expirado" });
      }

      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);

      // Update user password
      await storage.updateUserPassword(decoded.userId, hashedPassword);

      res.json({
        message: "Senha alterada com sucesso"
      });
    } catch (error) {
      console.error("Password reset error:", error);
      res.status(400).json({ message: "Erro ao redefinir senha" });
    }
  });

  app.get("/api/auth/me", authenticateToken, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.userId);
      if (!user) {
        return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });
      }

      // Check for pending deposits and update if paid
      const pendingDeposits = await storage.getDeposits(req.userId);
      const pendingOnes = pendingDeposits.filter((d) => d.status === "pending");

      for (const deposit of pendingOnes) {
        try {
          const verification = await verifyPixPayment(deposit.transactionId);

          if (verification.status === "completed") {
            // Update deposit status
            await storage.updateDepositStatus(
              deposit.transactionId,
              "completed",
            );

            // Update wallet balance
            const currentWallet = await storage.getWallet(deposit.userId);
            if (currentWallet && currentWallet.balance) {
              const newBalance =
                parseFloat(currentWallet.balance) + parseFloat(deposit.amount);
              await storage.updateWalletBalance(
                deposit.userId,
                newBalance.toFixed(2),
              );
            }
          }
        } catch (error) {
          console.error(
            "Error checking pending deposit:",
            deposit.transactionId,
            error,
          );
        }
      }

      const wallet = await storage.getWallet(user.id);

      res.json({
        id: user.id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        balance: wallet?.balance || "0.00",
      });
    } catch (error) {
      console.error("Me error:", error);
      res.status(500).json({ message: "Erro ao buscar usu√°rio" });
    }
  });

  // User balance route
  app.get("/api/user/balance", authenticateToken, async (req: any, res) => {
    try {
      // Check for pending deposits and update if paid
      const pendingDeposits = await storage.getDeposits(req.userId);
      const pendingOnes = pendingDeposits.filter((d) => d.status === "pending");

      for (const deposit of pendingOnes) {
        try {
          const verification = await verifyPixPayment(deposit.transactionId);

          if (verification.status === "completed") {
            // Update deposit status
            await storage.updateDepositStatus(
              deposit.transactionId,
              "completed",
            );

            // Update wallet balance
            const currentWallet = await storage.getWallet(deposit.userId);
            if (currentWallet && currentWallet.balance) {
              const newBalance =
                parseFloat(currentWallet.balance) + parseFloat(deposit.amount);
              await storage.updateWalletBalance(
                deposit.userId,
                newBalance.toFixed(2),
              );
            }
          }
        } catch (error) {
          console.error(
            "Error checking pending deposit:",
            deposit.transactionId,
            error,
          );
        }
      }

      // Get updated wallet balance
      const wallet = await storage.getWallet(req.userId);
      res.json({
        balance: wallet?.balance || "0.00",
        scratchBonus: wallet?.scratchBonus || 0,
        totalWagered: wallet?.totalWagered || "0.00",
      });
    } catch (error) {
      console.error("Balance error:", error);
      res.status(500).json({ message: "Erro ao buscar saldo" });
    }
  });

  // Update user profile
  app.patch(
    "/api/user/update-profile",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { name, email, phone } = req.body;

        // Validate input
        if (!name || !email || !phone) {
          return res
            .status(400)
            .json({ message: "Todos os campos s√£o obrigat√≥rios" });
        }

        // Check if email is already taken by another user
        const existingUser = await storage.getUserByEmail(email);
        if (existingUser && existingUser.id !== req.userId) {
          return res.status(400).json({ message: "Email j√° est√° em uso" });
        }

        // Update user profile
        await storage.updateUserProfile(req.userId, { name, email, phone });

        res.json({ message: "Perfil atualizado com sucesso" });
      } catch (error) {
        console.error("Update profile error:", error);
        res.status(500).json({ message: "Erro ao atualizar perfil" });
      }
    },
  );

  // Change user password
  app.post(
    "/api/user/change-password",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { currentPassword, newPassword } = req.body;

        // Get user
        const user = await storage.getUser(req.userId);
        if (!user) {
          return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });
        }

        // Verify current password
        const validPassword = await bcrypt.compare(
          currentPassword,
          user.password,
        );
        if (!validPassword) {
          return res.status(400).json({ message: "Senha atual incorreta" });
        }

        // Hash new password
        const hashedPassword = await bcrypt.hash(newPassword, 10);

        // Update password
        await storage.updateUserPassword(req.userId, hashedPassword);

        res.json({ message: "Senha alterada com sucesso" });
      } catch (error) {
        console.error("Change password error:", error);
        res.status(500).json({ message: "Erro ao alterar senha" });
      }
    },
  );

  // User Level route - Calculate level based on total wagered
  app.get("/api/user/level", authenticateToken, async (req: any, res) => {
    try {
      const wallet = await storage.getWallet(req.userId);
      const totalWagered = parseFloat(wallet?.totalWagered || "0");

      // Calculate current level (0-100) based on total wagered
      // Custom thresholds for reward levels with exponential growth
      const levelThresholds: Record<number, number> = {
        1: 100, // R$100 apostados
        5: 1000, // R$1,000 apostados
        10: 5000, // R$5,000 apostados
        20: 20000, // R$20,000 apostados
        30: 50000, // R$50,000 apostados
        50: 150000, // R$150,000 apostados
        70: 300000, // R$300,000 apostados
        100: 1000000, // R$1,000,000 apostados
      };

      // Function to calculate required amount for any level
      function getRequiredForLevel(n: number): number {
        if (levelThresholds[n]) {
          return levelThresholds[n];
        }
        // Exponential growth between reward levels
        const rewardLevels = [1, 5, 10, 20, 30, 50, 70, 100];
        const prevRewardLevel = rewardLevels.filter((l) => l < n).pop() || 0;
        const nextRewardLevel = rewardLevels.find((l) => l > n) || 100;

        if (prevRewardLevel === 0) return n * 20; // Levels 2-4

        const prevRequired = levelThresholds[prevRewardLevel];
        const nextRequired = levelThresholds[nextRewardLevel];
        const levelsBetween = nextRewardLevel - prevRewardLevel;
        const positionBetween = n - prevRewardLevel;

        return Math.floor(
          prevRequired +
            ((nextRequired - prevRequired) / levelsBetween) * positionBetween,
        );
      }

      let level = 0;
      let levelProgress = 0;
      let requiredForCurrentLevel = 0;
      let requiredForNextLevel = getRequiredForLevel(1);

      // Find current level
      for (let n = 1; n <= 100; n++) {
        const requiredAmount = getRequiredForLevel(n);

        if (totalWagered >= requiredAmount) {
          level = n;
          requiredForCurrentLevel = requiredAmount;
          // Calculate requirement for next level
          if (n < 100) {
            requiredForNextLevel = getRequiredForLevel(n + 1);
          } else {
            requiredForNextLevel = requiredAmount; // Max level
          }
        } else {
          break;
        }
      }

      // Calculate progress to next level
      if (level < 100) {
        const progressAmount = totalWagered - requiredForCurrentLevel;
        const neededAmount = requiredForNextLevel - requiredForCurrentLevel;
        levelProgress = Math.floor((progressAmount / neededAmount) * 100);
      } else {
        levelProgress = 100; // Max level
      }

      res.json({
        level,
        totalWagered: totalWagered.toFixed(2),
        requiredForCurrentLevel: requiredForCurrentLevel.toFixed(2),
        requiredForNextLevel: requiredForNextLevel.toFixed(2),
        progress: levelProgress,
        maxLevel: level === 100,
      });
    } catch (error) {
      console.error("Level error:", error);
      res.status(500).json({ error: "Error fetching level" });
    }
  });

  // User XP route (kept for backwards compatibility)
  app.get("/api/user/xp", authenticateToken, async (req: any, res) => {
    try {
      const games = await storage.getGamesByUser(req.userId);
      const xp = games.length * 10;
      res.json({ xp });
    } catch (error) {
      console.error("XP error:", error);
      res.status(500).json({ error: "Error fetching XP" });
    }
  });

  // Level rewards route - Get available rewards and claimed status
  app.get("/api/level/rewards", authenticateToken, async (req: any, res) => {
    try {
      const wallet = await storage.getWallet(req.userId);
      const totalWagered = parseFloat(wallet?.totalWagered || "0");
      const claimedRewards = await storage.getLevelRewardsClaimed(req.userId);

      // Define rewards for specific levels only - Total: R$50,000
      const levelRewards: Record<number, number> = {
        1: 10, // R$10 (0.02%)
        5: 50, // R$50 (0.1%)
        10: 100, // R$100 (0.2%)
        20: 250, // R$250 (0.5%)
        30: 500, // R$500 (1%)
        50: 2000, // R$2,000 (4%)
        70: 5590, // R$5,590 (11.18%)
        100: 41500, // R$41,500 (83%)
      };

      // Custom thresholds for reward levels
      const levelThresholds: Record<number, number> = {
        1: 100, // R$100 apostados
        5: 1000, // R$1,000 apostados
        10: 5000, // R$5,000 apostados
        20: 20000, // R$20,000 apostados
        30: 50000, // R$50,000 apostados
        50: 150000, // R$150,000 apostados
        70: 300000, // R$300,000 apostados
        100: 1000000, // R$1,000,000 apostados
      };

      // Function to calculate required amount for any level
      function getRequiredForLevel(n: number): number {
        if (levelThresholds[n]) {
          return levelThresholds[n];
        }
        const rewardLevels = [1, 5, 10, 20, 30, 50, 70, 100];
        const prevRewardLevel = rewardLevels.filter((l) => l < n).pop() || 0;
        const nextRewardLevel = rewardLevels.find((l) => l > n) || 100;

        if (prevRewardLevel === 0) return n * 20;

        const prevRequired = levelThresholds[prevRewardLevel];
        const nextRequired = levelThresholds[nextRewardLevel];
        const levelsBetween = nextRewardLevel - prevRewardLevel;
        const positionBetween = n - prevRewardLevel;

        return Math.floor(
          prevRequired +
            ((nextRequired - prevRequired) / levelsBetween) * positionBetween,
        );
      }

      // Calculate current level
      let currentLevel = 0;
      for (let n = 1; n <= 100; n++) {
        const requiredAmount = getRequiredForLevel(n);
        if (totalWagered >= requiredAmount) {
          currentLevel = n;
        } else {
          break;
        }
      }

      // Build rewards list with claimed status (only for levels that have rewards)
      const rewards = [];
      for (let level = 1; level <= currentLevel; level++) {
        if (levelRewards[level]) {
          const claimed = claimedRewards.some((r) => r.level === level);
          rewards.push({
            level,
            reward: levelRewards[level],
            claimed,
            available: !claimed,
          });
        }
      }

      res.json({
        currentLevel,
        totalWagered: totalWagered.toFixed(2),
        rewards,
        totalUnclaimed: rewards
          .filter((r) => r.available)
          .reduce((sum, r) => sum + r.reward, 0),
      });
    } catch (error) {
      console.error("Level rewards error:", error);
      res.status(500).json({ error: "Error fetching level rewards" });
    }
  });

  // Claim level reward
  app.post(
    "/api/level/claim/:level",
    authenticateToken,
    async (req: any, res) => {
      try {
        const level = parseInt(req.params.level);

        // Verify user has reached this level
        const wallet = await storage.getWallet(req.userId);
        const totalWagered = parseFloat(wallet?.totalWagered || "0");

        // Custom thresholds for reward levels
        const levelThresholds: Record<number, number> = {
          1: 100, // R$100 apostados
          5: 1000, // R$1,000 apostados
          10: 5000, // R$5,000 apostados
          20: 20000, // R$20,000 apostados
          30: 50000, // R$50,000 apostados
          50: 150000, // R$150,000 apostados
          70: 300000, // R$300,000 apostados
          100: 1000000, // R$1,000,000 apostados
        };

        // Function to calculate required amount for any level
        function getRequiredForLevel(n: number): number {
          if (levelThresholds[n]) {
            return levelThresholds[n];
          }
          const rewardLevels = [1, 5, 10, 20, 30, 50, 70, 100];
          const prevRewardLevel = rewardLevels.filter((l) => l < n).pop() || 0;
          const nextRewardLevel = rewardLevels.find((l) => l > n) || 100;

          if (prevRewardLevel === 0) return n * 20;

          const prevRequired = levelThresholds[prevRewardLevel];
          const nextRequired = levelThresholds[nextRewardLevel];
          const levelsBetween = nextRewardLevel - prevRewardLevel;
          const positionBetween = n - prevRewardLevel;

          return Math.floor(
            prevRequired +
              ((nextRequired - prevRequired) / levelsBetween) * positionBetween,
          );
        }

        // Calculate if user has reached this level
        const requiredAmount = getRequiredForLevel(level);
        if (totalWagered < requiredAmount) {
          return res
            .status(400)
            .json({ error: "Voc√™ ainda n√£o alcan√ßou este n√≠vel" });
        }

        // Check if already claimed
        const alreadyClaimed = await storage.hasClaimedLevelReward(
          req.userId,
          level,
        );
        if (alreadyClaimed) {
          return res.status(400).json({ error: "Recompensa j√° resgatada" });
        }

        // Define rewards for specific levels - now in scratch bonus tickets
        const levelRewards: Record<number, number> = {
          1: 10, // 10 raspadinhas
          5: 50, // 50 raspadinhas
          10: 100, // 100 raspadinhas
          20: 250, // 250 raspadinhas
          30: 500, // 500 raspadinhas
          50: 2000, // 2000 raspadinhas
          70: 5590, // 5590 raspadinhas
          100: 41500, // 41500 raspadinhas
        };

        const rewardAmount = levelRewards[level];
        if (!rewardAmount) {
          return res.status(400).json({ error: "N√≠vel inv√°lido" });
        }

        // Add reward to user scratch bonus
        const currentScratchBonus = wallet?.scratchBonus || 0;
        const newScratchBonus = currentScratchBonus + rewardAmount;
        await storage.updateWalletScratchBonus(req.userId, newScratchBonus);

        // Record the claim
        await storage.createLevelRewardClaimed({
          userId: req.userId,
          level,
          reward: rewardAmount.toString(),
        });

        res.json({
          success: true,
          reward: rewardAmount,
          newScratchBonus: newScratchBonus,
        });
      } catch (error) {
        console.error("Claim reward error:", error);
        res.status(500).json({ error: "Erro ao resgatar recompensa" });
      }
    },
  );

  app.get(
    "/api/user/transactions",
    authenticateToken,
    async (req: any, res) => {
      try {
        // Get deposits and withdrawals for the user
        const deposits = await storage.getDepositsByUser(req.userId);
        const withdrawals = await storage.getWithdrawalsByUser(req.userId);

        console.log(
          "Raw withdrawals from DB:",
          JSON.stringify(withdrawals, null, 2),
        );

        // Format deposits
        const formattedDeposits = deposits.map((d: any) => ({
          id: d.id,
          displayId: d.displayId,
          type: "deposit",
          amount: d.amount,
          status: d.status,
          transactionId: d.transactionId,
          createdAt: d.createdAt,
        }));

        // Format withdrawals
        const formattedWithdrawals = withdrawals.map((w: any) => ({
          id: w.id,
          displayId: w.displayId,
          type: "withdrawal",
          amount: w.amount,
          status: w.status,
          pixKey: w.pixKey,
          pixKeyType: w.pixKeyType,
          createdAt: w.requestedAt || w.createdAt, // Use requestedAt from withdrawals table
          requestedAt: w.requestedAt, // Also include requestedAt for debugging
        }));

        // Combine and sort by date
        const allTransactions = [
          ...formattedDeposits,
          ...formattedWithdrawals,
        ].sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
        );

        console.log("Formatted withdrawals:", formattedWithdrawals);

        res.json(allTransactions);
      } catch (error) {
        console.error("Get transactions error:", error);
        res.status(500).json({ error: "Error fetching transactions" });
      }
    },
  );

  // Withdrawal routes
  app.post(
    "/api/withdrawals/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { amount, pixKey } = req.body;

        // Validate input
        if (!amount || !pixKey) {
          return res
            .status(400)
            .json({ error: "Valor e chave PIX s√£o obrigat√≥rios" });
        }

        const withdrawalAmount = parseFloat(amount);
        if (isNaN(withdrawalAmount) || withdrawalAmount <= 0) {
          return res.status(400).json({ error: "Valor inv√°lido" });
        }

        // Identify PIX key type
        const pixKeyType = identifyPixKeyType(pixKey);
        if (!pixKeyType) {
          return res.status(400).json({ error: "Chave PIX inv√°lida" });
        }

        // Get user wallet
        const wallet = await storage.getWallet(req.userId);
        if (!wallet) {
          return res.status(400).json({ error: "Carteira n√£o encontrada" });
        }

        // Check if user has sufficient balance
        const currentBalance = parseFloat(wallet.balance);
        if (currentBalance < withdrawalAmount) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Deduct amount from wallet
        const newBalance = currentBalance - withdrawalAmount;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));

        // Create withdrawal request
        const withdrawal = await storage.createWithdrawal({
          userId: req.userId,
          amount: withdrawalAmount.toFixed(2),
          pixKey,
          pixKeyType,
          status: "pending",
        });

        console.log("Created withdrawal:", withdrawal);

        res.json({
          message: "Saque solicitado com sucesso",
          withdrawal,
        });
      } catch (error) {
        console.error("Create withdrawal error:", error);
        res.status(500).json({ error: "Erro ao processar saque" });
      }
    },
  );

  app.post(
    "/api/withdrawals/:id/cancel",
    authenticateToken,
    async (req: any, res) => {
      try {
        const withdrawalId = parseInt(req.params.id);

        // Get withdrawal
        const withdrawal = await storage.getWithdrawal(withdrawalId);
        if (!withdrawal) {
          return res.status(404).json({ error: "Saque n√£o encontrado" });
        }

        // Check if withdrawal belongs to user
        if (withdrawal.userId !== req.userId) {
          return res.status(403).json({ error: "Acesso negado" });
        }

        // Check if withdrawal can be cancelled
        if (withdrawal.status !== "pending") {
          return res
            .status(400)
            .json({ error: "Este saque n√£o pode ser cancelado" });
        }

        // Get user wallet
        const wallet = await storage.getWallet(req.userId);
        if (!wallet) {
          return res.status(400).json({ error: "Carteira n√£o encontrada" });
        }

        // Refund amount to wallet
        const currentBalance = parseFloat(wallet.balance);
        const refundAmount = parseFloat(withdrawal.amount);
        const newBalance = currentBalance + refundAmount;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));

        // Update withdrawal status
        await storage.updateWithdrawalStatus(withdrawalId, "cancelled");

        res.json({
          message: "Saque cancelado com sucesso",
          newBalance: newBalance.toFixed(2),
        });
      } catch (error) {
        console.error("Cancel withdrawal error:", error);
        res.status(500).json({ error: "Erro ao cancelar saque" });
      }
    },
  );

  // Helper function to identify PIX key type
  function identifyPixKeyType(pixKey: string): string | null {
    // Remove spaces and special characters for validation
    const cleanKey = pixKey.replace(/[\s\-\.]/g, "");

    // CPF pattern (11 digits)
    if (/^\d{11}$/.test(cleanKey)) {
      return "cpf";
    }

    // Phone pattern (10 or 11 digits, optionally with +55)
    if (/^(\+55)?[1-9]{2}[9]?\d{8}$/.test(cleanKey)) {
      return "phone";
    }

    // Email pattern
    if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(pixKey)) {
      return "email";
    }

    // Random key pattern (UUID format)
    if (
      /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(
        pixKey,
      )
    ) {
      return "random";
    }

    // If none match, assume it's a random key (could be any format)
    if (pixKey.length >= 10) {
      return "random";
    }

    return null;
  }

  // Game routes

  // Raspadinha PIX routes
  app.post(
    "/api/games/pix/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { mode = "normal" } = req.body;
        const wallet = await storage.getWallet(req.userId);

        const gameModes: Record<string, { cost: number; multiplier: number }> =
          {
            normal: { cost: 1, multiplier: 1 },
            prata: { cost: 5, multiplier: 5 },
            ouro: { cost: 10, multiplier: 10 },
            diamante: { cost: 100, multiplier: 100 },
          };

        const gameMode = gameModes[mode] || gameModes.normal;

        if (!wallet || parseFloat(wallet.balance) < gameMode.cost) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Generate random values
        const possibleValues = [
          "R$ 0,50",
          "R$ 1",
          "R$ 2",
          "R$ 10",
          "R$ 50",
          "R$ 100",
          "R$ 500",
          "R$ 1000",
        ];
        const values = [];
        for (let i = 0; i < 9; i++) {
          values.push(
            possibleValues[Math.floor(Math.random() * possibleValues.length)],
          );
        }

        // Determine if won (simplified logic)
        const won = Math.random() < 0.15; // 15% chance
        if (won) {
          const winValue = possibleValues[Math.floor(Math.random() * 4)]; // Lower values more likely
          values[0] = winValue;
          values[4] = winValue;
          values[8] = winValue;
        }

        // Deduct cost and update total wagered
        const newBalance = parseFloat(wallet.balance) - gameMode.cost;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
        await storage.incrementTotalWagered(
          req.userId,
          gameMode.cost.toString(),
        );

        // Store game state
        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "pix",
          mode,
          cost: gameMode.cost,
          values,
          won,
          createdAt: new Date(),
        });

        res.json({
          gameId,
          hiddenValues: values,
          mode,
          cost: gameMode.cost,
        });
      } catch (error) {
        console.error("PIX game error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/pix/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { won, mode, cost } = gameState;
        let prize = 0;

        if (won) {
          // Prize based on mode
          const modeMultipliers: Record<string, number> = {
            normal: 1,
            prata: 5,
            ouro: 10,
            diamante: 100,
          };

          const basePrizes = [2, 5, 10, 20, 50, 100];
          const basePrize =
            basePrizes[Math.floor(Math.random() * basePrizes.length)];
          prize = basePrize * (modeMultipliers[mode] || 1);
        }

        if (prize > 0) {
          const wallet = await storage.getWallet(req.userId);
          if (wallet) {
            const newBalance = parseFloat(wallet.balance) + prize;
            await storage.updateWalletBalance(
              req.userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Save game result to minigames table
        await storage.createGameMinigame({
          userId: req.userId,
          gameType: "sorte",
          cost: cost.toString(),
          prize: prize.toString(),
          result: JSON.stringify({ gameId, won, mode }),
          won,
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ won, prize });
      } catch (error) {
        console.error("PIX reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar resultado" });
      }
    },
  );

  // Mines routes
  app.post(
    "/api/games/mines/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { betAmount = 1, bombCount = 3 } = req.body;
        const wallet = await storage.getWallet(req.userId);

        if (!wallet || parseFloat(wallet.balance) < betAmount) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Check if this is the test account
        const user = await storage.getUser(req.userId);
        const isTestAccount = user?.email === "teste@gmail.com";

        // Generate bomb positions
        const bombPositions: number[] = [];

        if (isTestAccount) {
          // For test account, place bombs in predictable positions (corners)
          // This makes it easier to avoid them
          const cornerPositions = [0, 4, 15, 19]; // Four corners
          for (let i = 0; i < Math.min(bombCount, 4); i++) {
            bombPositions.push(cornerPositions[i]);
          }
          // If more than 4 bombs, add them to edges
          if (bombCount > 4) {
            const edgePositions = [1, 2, 3, 5, 9, 10, 14, 16, 17, 18];
            for (
              let i = 4;
              i < bombCount && i - 4 < edgePositions.length;
              i++
            ) {
              bombPositions.push(edgePositions[i - 4]);
            }
          }
        } else {
          // Normal random bomb placement for other users
          while (bombPositions.length < bombCount) {
            const pos = Math.floor(Math.random() * 20);
            if (!bombPositions.includes(pos)) {
              bombPositions.push(pos);
            }
          }
        }

        // Deduct bet and update total wagered
        const newBalance = parseFloat(wallet.balance) - betAmount;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
        await storage.incrementTotalWagered(req.userId, betAmount.toString());

        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "mines",
          betAmount,
          bombCount,
          bombPositions,
          revealedTiles: [],
          createdAt: new Date(),
        });

        res.json({
          gameId,
          bombPositions,
          betAmount,
        });
      } catch (error) {
        console.error("Mines create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  // Update revealed tiles endpoint
  app.post(
    "/api/games/mines/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const { index } = req.body;

        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        // Add to revealed tiles
        if (!gameState.revealedTiles.includes(index)) {
          gameState.revealedTiles.push(index);
        }

        res.json({ success: true });
      } catch (error) {
        console.error("Mines reveal tile error:", error);
        res.status(500).json({ error: "Erro ao revelar tile" });
      }
    },
  );

  app.post(
    "/api/games/mines/:gameId/lose",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const { hitIndex, clickedIndices } = req.body;

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { betAmount, bombCount, revealedTiles, bombPositions } =
          gameState;

        // Save game result to minigames table with complete game data
        const fullGameData = {
          tiles: Array(20)
            .fill(null)
            .map((_, index) => ({
              revealed:
                clickedIndices?.includes(index) ||
                bombPositions.includes(index),
              isBomb: bombPositions.includes(index),
            })),
          bombCount: bombCount,
          betAmount: betAmount,
          hitBombIndex: hitIndex,
          revealedBeforeLoss: clickedIndices?.length || 0,
          clickedIndices: clickedIndices || [],
        };

        await storage.createGameMinigame({
          userId: req.userId,
          gameType: "mines",
          cost: betAmount.toString(),
          prize: "0",
          result: JSON.stringify({
            gameId,
            lost: true,
            hitBombIndex: hitIndex,
          }),
          won: false,
          gameData: JSON.stringify(fullGameData),
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ lost: true });
      } catch (error) {
        console.error("Mines lose error:", error);
        res.status(500).json({ error: "Erro ao registrar perda" });
      }
    },
  );

  app.post(
    "/api/games/mines/:gameId/cashout",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const { clickedIndices } = req.body;

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { betAmount, bombCount, revealedTiles } = gameState;
        const safeRevealed =
          clickedIndices?.length || revealedTiles?.length || 1;

        // Calculate multiplier based on safe tiles revealed
        const baseMultiplier = 1.15; // 15% increase per safe tile
        const multiplier = Math.pow(baseMultiplier, safeRevealed);
        const prize = Math.floor(betAmount * multiplier * 100) / 100;

        const wallet = await storage.getWallet(req.userId);
        if (wallet) {
          const newBalance = parseFloat(wallet.balance) + prize;
          await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
        }

        // Save game result to minigames table with complete game data
        const fullGameData = {
          tiles: Array(20)
            .fill(null)
            .map((_, index) => ({
              revealed:
                clickedIndices?.includes(index) ||
                revealedTiles?.includes(index) ||
                false,
              isBomb: gameState.bombPositions.includes(index),
            })),
          bombCount: bombCount,
          betAmount: betAmount,
          multiplier: multiplier,
          safeRevealed: safeRevealed,
          clickedIndices: clickedIndices || revealedTiles || [],
        };

        await storage.createGameMinigame({
          userId: req.userId,
          gameType: "mines",
          cost: betAmount.toString(),
          prize: prize.toString(),
          result: JSON.stringify({ gameId, safeRevealed, multiplier }),
          won: true,
          gameData: JSON.stringify(fullGameData),
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ prize });
      } catch (error) {
        console.error("Mines cashout error:", error);
        res.status(500).json({ error: "Erro ao sacar" });
      }
    },
  );

  // Double routes
  app.post(
    "/api/games/double/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { betAmount = 1, selectedColor } = req.body;
        const wallet = await storage.getWallet(req.userId);

        if (!wallet || parseFloat(wallet.balance) < betAmount) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Check if this is the test account
        const user = await storage.getUser(req.userId);
        const isTestAccount = user?.email === "teste@gmail.com";

        // Generate grid colors
        const gridColors: string[] = [];

        if (isTestAccount && selectedColor) {
          // For test account, place selected color in most positions (98% win rate)
          // Fill 18 positions with selected color, 2 with others
          for (let i = 0; i < 18; i++) {
            gridColors.push(selectedColor);
          }

          // Add 1 of each other color
          if (selectedColor === "black") {
            gridColors.push("red", "purple");
          } else if (selectedColor === "red") {
            gridColors.push("black", "purple");
          } else {
            gridColors.push("black", "red");
          }
        } else {
          // Normal distribution for other users
          // 9 black, 9 red, 2 purple
          for (let i = 0; i < 9; i++) gridColors.push("black");
          for (let i = 0; i < 9; i++) gridColors.push("red");
          for (let i = 0; i < 2; i++) gridColors.push("purple");
        }

        // Shuffle
        for (let i = gridColors.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [gridColors[i], gridColors[j]] = [gridColors[j], gridColors[i]];
        }

        // Deduct bet and update total wagered
        const newBalance = parseFloat(wallet.balance) - betAmount;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
        await storage.incrementTotalWagered(req.userId, betAmount.toString());

        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "double",
          betAmount,
          selectedColor,
          gridColors,
          createdAt: new Date(),
        });

        res.json({
          gameId,
          gridColors,
          betAmount,
          selectedColor,
        });
      } catch (error) {
        console.error("Double create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/double/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const { revealedIndex } = req.body;

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { betAmount, selectedColor, gridColors } = gameState;
        const revealedColor = gridColors[revealedIndex];

        const won = revealedColor === selectedColor;
        let prize = 0;

        if (won) {
          const multipliers = { black: 2, red: 2, purple: 10 };
          prize =
            betAmount * multipliers[revealedColor as keyof typeof multipliers];

          const wallet = await storage.getWallet(req.userId);
          if (wallet) {
            const newBalance = parseFloat(wallet.balance) + prize;
            await storage.updateWalletBalance(
              req.userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Save game result to minigames table with complete game data
        const fullGameData = {
          gridColors: gridColors,
          selectedColor: selectedColor,
          revealedColor: revealedColor,
          revealedIndex: revealedIndex,
          multiplier: won ? (revealedColor === "purple" ? 10 : 2) : 0,
          rounds: [
            {
              selectedColor: selectedColor,
              revealedColor: revealedColor,
              won: won,
            },
          ],
          finalMultiplier: won ? (revealedColor === "purple" ? 10 : 2) : 0,
        };

        await storage.createGameMinigame({
          userId: req.userId,
          gameType: "double",
          cost: betAmount.toString(),
          prize: prize.toString(),
          result: JSON.stringify({ gameId, revealedColor, selectedColor }),
          won,
          gameData: JSON.stringify(fullGameData),
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ won, prize });
      } catch (error) {
        console.error("Double reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar" });
      }
    },
  );

  // Infect routes
  app.post(
    "/api/games/infect/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { betAmount = 1, difficulty = "medium" } = req.body;
        const wallet = await storage.getWallet(req.userId);

        if (!wallet || parseFloat(wallet.balance) < betAmount) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Check if this is the test account
        const user = await storage.getUser(req.userId);
        const isTestAccount = user?.email === "teste@gmail.com";

        // Generate infected positions for each level
        const infectedPositions: number[] = [];
        const columns =
          difficulty === "easy" ? 4 : difficulty === "medium" ? 3 : 2;

        if (isTestAccount) {
          // For test account, always place infected tiles in first column (easy to avoid)
          for (let level = 0; level < 9; level++) {
            infectedPositions.push(0); // Always first column
          }
        } else {
          // Random positions for normal users
          for (let level = 0; level < 9; level++) {
            infectedPositions.push(Math.floor(Math.random() * columns));
          }
        }

        // Deduct bet and update total wagered
        const newBalance = parseFloat(wallet.balance) - betAmount;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
        await storage.incrementTotalWagered(req.userId, betAmount.toString());

        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "infect",
          betAmount,
          difficulty,
          infectedPositions,
          currentLevel: 0,
          createdAt: new Date(),
        });

        res.json({
          gameId,
          infectedPositions,
          betAmount,
          difficulty,
        });
      } catch (error) {
        console.error("Infect create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/infect/:gameId/lose",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const { level, hitIndex, clickedTiles } = req.body;

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { betAmount, difficulty, infectedPositions } = gameState;
        const columns =
          difficulty === "easy" ? 4 : difficulty === "medium" ? 3 : 2;

        // Save game result to minigames table with complete game data
        const fullGameData = {
          levels: Array(9)
            .fill(null)
            .map((_, levelIndex) => ({
              tiles: Array(columns)
                .fill(null)
                .map((_, tileIndex) => ({
                  revealed: clickedTiles?.[levelIndex]?.[tileIndex] || false,
                  infected: tileIndex === infectedPositions[levelIndex],
                  clicked: clickedTiles?.[levelIndex]?.[tileIndex] || false,
                })),
            })),
          currentLevel: level,
          difficulty: difficulty,
          hitInfectedAt: { level, tile: hitIndex },
          infectedPositions: infectedPositions,
          clickedTiles: clickedTiles,
        };

        await storage.createGameMinigame({
          userId: req.userId,
          gameType: "infect",
          cost: betAmount.toString(),
          prize: "0",
          result: JSON.stringify({ gameId, lost: true, lostAtLevel: level }),
          won: false,
          gameData: JSON.stringify(fullGameData),
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ lost: true });
      } catch (error) {
        console.error("Infect lose error:", error);
        res.status(500).json({ error: "Erro ao registrar perda" });
      }
    },
  );

  app.post(
    "/api/games/infect/:gameId/cashout",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const { level = 0, clickedTiles } = req.body;

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { betAmount, difficulty } = gameState;

        // Calculate multiplier based on level and difficulty
        const difficultyMultipliers = { easy: 1.3, medium: 1.5, hard: 2 };
        const baseMultiplier =
          difficultyMultipliers[
            difficulty as keyof typeof difficultyMultipliers
          ];
        const multiplier = Math.pow(baseMultiplier, level);
        const prize = Math.floor(betAmount * multiplier * 100) / 100;

        const wallet = await storage.getWallet(req.userId);
        if (wallet) {
          const newBalance = parseFloat(wallet.balance) + prize;
          await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
        }

        // Save game result to minigames table with complete game data
        const columns =
          difficulty === "easy" ? 4 : difficulty === "medium" ? 3 : 2;
        const fullGameData = {
          levels: Array(9)
            .fill(null)
            .map((_, levelIndex) => ({
              tiles: Array(columns)
                .fill(null)
                .map((_, tileIndex) => ({
                  revealed: clickedTiles?.[levelIndex]?.[tileIndex] || false,
                  infected:
                    tileIndex === gameState.infectedPositions[levelIndex],
                  clicked: clickedTiles?.[levelIndex]?.[tileIndex] || false,
                })),
            })),
          currentLevel: level,
          difficulty: difficulty,
          multiplier: multiplier,
          infectedPositions: gameState.infectedPositions,
          clickedTiles: clickedTiles,
        };

        await storage.createGameMinigame({
          userId: req.userId,
          gameType: "infect",
          cost: betAmount.toString(),
          prize: prize.toString(),
          result: JSON.stringify({ gameId, level, difficulty, multiplier }),
          won: true,
          gameData: JSON.stringify(fullGameData),
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ prize });
      } catch (error) {
        console.error("Infect cashout error:", error);
        res.status(500).json({ error: "Erro ao sacar" });
      }
    },
  );

  // Prize Scratch Card Games

  // Premio PIX routes
  app.post(
    "/api/games/premio-pix/create",
    authenticateOptionalWithWelcome,
    async (req: any, res) => {
      try {
        const { multiplier = 1, freePlay = false, useBonus = false, isWelcomeUser = false } = req.body;
        const userId = req.userId;
        
        // For non-authenticated users, skip wallet checks
        if (!userId) {
          if (!freePlay || !isWelcomeUser) {
            return res.status(401).json({ error: "Autentica√ß√£o requerida" });
          }
        }
        
        const wallet = userId ? await storage.getWallet(userId) : null;
        const baseCost = 1.00; // Base cost for PIX scratch card
        const cost = (freePlay || useBonus) ? 0 : baseCost * multiplier;
        const scratchBonusCost = useBonus ? multiplier : 0; // Scratch bonus cost is multiplier

        if (!freePlay && !useBonus && userId && (!wallet || parseFloat(wallet.balance) < cost)) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Fetch PIX prizes from database
        let prizeData: any[] = [];
        try {
          const prizeProbabilities = await storage.getPrizeProbabilities('pix');
          prizeData = prizeProbabilities.map(p => ({
            value: p.prize_value,
            numericValue: parseFloat(p.prize_value),
            probability: parseFloat(p.probability) // Convert string to number!
          }));
          console.log("PIX probabilities loaded from database:", prizeData.map(p => ({ value: p.value, prob: p.probability })));
        } catch (error) {
          console.error("Error fetching PIX prize probabilities, using defaults:", error);
          // Fallback to default values if database fetch fails
          prizeData = [
            { value: "0.50", numericValue: 0.5, probability: 28.00 },
            { value: "1.00", numericValue: 1, probability: 20.00 },
            { value: "2.00", numericValue: 2, probability: 8.00 },
            { value: "3.00", numericValue: 3, probability: 4.00 },
            { value: "4.00", numericValue: 4, probability: 2.00 },
            { value: "5.00", numericValue: 5, probability: 1.50 },
            { value: "10.00", numericValue: 10, probability: 0.80 },
            { value: "15.00", numericValue: 15, probability: 0.40 },
            { value: "20.00", numericValue: 20, probability: 0.30 },
            { value: "50.00", numericValue: 50, probability: 0.10 },
            { value: "100.00", numericValue: 100, probability: 0.05 },
            { value: "200.00", numericValue: 200, probability: 0.02 },
            { value: "500.00", numericValue: 500, probability: 0.01 },
            { value: "1000.00", numericValue: 1000, probability: 0.005 },
            { value: "2000.00", numericValue: 2000, probability: 0.002 },
            { value: "5000.00", numericValue: 5000, probability: 0.001 },
            { value: "10000.00", numericValue: 10000, probability: 0.0002 },
            { value: "100000.00", numericValue: 100000, probability: 0.00001 }
          ];
        }

        const hiddenValues: string[] = [];

        // Check if this is the test account
        const user = userId ? await storage.getUser(userId) : null;
        const isTestAccount = user?.email === "teste@gmail.com";

        // NEW LOGIC: Each prize has its own independent probability
        let winningValue: string | null = null;
        
        if (isTestAccount) {
          // Test account always wins - pick a random prize weighted by probability
          const totalProb = prizeData.reduce((sum, p) => sum + p.probability, 0);
          const rand = Math.random() * totalProb;
          let accumulator = 0;
          
          for (const prize of prizeData) {
            accumulator += prize.probability;
            if (rand <= accumulator) {
              winningValue = prize.value;
              break;
            }
          }
          console.log("Test account detected - always wins:", winningValue);
        } else {
          // Regular logic: Test each prize independently
          const roll = Math.random() * 100;
          
          // Go through each prize and check if we hit its probability
          for (const prize of prizeData) {
            if (roll < prize.probability) {
              winningValue = prize.value;
              console.log(`Won ${prize.value} - rolled ${roll.toFixed(2)}, probability: ${prize.probability}%`);
              break;
            }
          }
          
          if (!winningValue) {
            console.log(`Lost - rolled ${roll.toFixed(2)}, no prize hit`);
          }
        }

        // Generate the grid based on whether we have a winner
        if (winningValue) {
          // Place winning value 3 times
          hiddenValues.push(winningValue, winningValue, winningValue);

          // Fill rest with random values (ensuring no accidental 3-match)
          const allValues = prizeData.map(p => p.value).concat(["", "", ""]);
          for (let i = 3; i < 9; i++) {
            let value;
            do {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            } while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            );
            hiddenValues.push(value);
          }
        } else {
          // Generate non-winning grid
          const allValues = prizeData.map(p => p.value).concat(["", "", "", ""]);
          for (let i = 0; i < 9; i++) {
            let value = allValues[Math.floor(Math.random() * allValues.length)];
            // Ensure no value appears 3 times
            while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            ) {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            }
            hiddenValues.push(value);
          }
        }

        // Shuffle the values
        for (let i = hiddenValues.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [hiddenValues[i], hiddenValues[j]] = [
            hiddenValues[j],
            hiddenValues[i],
          ];
        }

        // Check if user has sufficient scratch bonus when using bonus
        if (useBonus && userId && wallet) {
          const currentScratchBonus = wallet.scratchBonus || 0;
          if (currentScratchBonus < scratchBonusCost) {
            return res.status(400).json({ error: "Raspadinhas B√¥nus insuficientes" });
          }
        }
        
        // Deduct cost or scratch bonus
        if (!freePlay && wallet && userId) {
          if (useBonus) {
            // Deduct from scratch bonus
            const newScratchBonus = (wallet.scratchBonus || 0) - scratchBonusCost;
            await storage.updateWalletScratchBonus(userId, newScratchBonus);
          } else {
            // Deduct from real balance
            const newBalance = parseFloat(wallet.balance) - cost;
            await storage.updateWalletBalance(userId, newBalance.toFixed(2));
            await storage.incrementTotalWagered(userId, cost.toString());
          }
        }

        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: userId || 'welcome-' + gameId, // Use a special ID for welcome users
          type: "premio-pix",
          hiddenValues,
          cost,
          multiplier, // Store multiplier to apply to prizes
          createdAt: new Date(),
        });

        res.json({ gameId, hiddenValues });
      } catch (error) {
        console.error("Premio PIX create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/premio-pix/:gameId/reveal",
    authenticateOptionalWithWelcome,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const userId = req.userId;
        const isWelcomeUser = req.isWelcomeUser;

        const gameState = activeGames.get(gameId);
        if (!gameState) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }
        
        // Check if the game belongs to the current user or welcome user
        const expectedUserId = userId || 'welcome-' + gameId;
        if (gameState.userId !== expectedUserId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { hiddenValues, cost, multiplier = 1 } = gameState;

        // Check for winning condition (3 matching non-empty values)
        const valueCounts = hiddenValues.reduce((acc: any, val: string) => {
          if (val && val !== "") {
            acc[val] = (acc[val] || 0) + 1;
          }
          return acc;
        }, {});

        const winningValue = Object.entries(valueCounts).find(
          ([_, count]: any) => count >= 3,
        );
        const won = !!winningValue;
        const prizeValue = won ? winningValue![0] : "";
        
        // Extract numeric value from prize value and apply multiplier
        let numericPrize = 0;
        if (won && prizeValue) {
          const basePrize = parseFloat(prizeValue) || 0;
          numericPrize = basePrize * multiplier; // Apply multiplier to prize
        }

        if (won && numericPrize > 0 && userId) {
          const wallet = await storage.getWallet(userId);
          if (wallet) {
            const newBalance = parseFloat(wallet.balance) + numericPrize;
            await storage.updateWalletBalance(
              userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Save game result to premios table only for authenticated users
        if (userId) {
          await storage.createGamePremio({
            userId: userId,
            gameType: "pix",
            cost: cost.toString(),
            prize: numericPrize.toString(),
            result: JSON.stringify({ gameId, hiddenValues, prizeValue }),
            won,
          });
        }

        activeGames.delete(gameId);
        
        // Clean up active game session
        if (userId) {
          const sessions = await storage.getUserActiveGameSessions(userId);
          for (const session of sessions) {
            if (session.gameType === 'premio-pix' && session.gameState?.gameId === gameId) {
              await storage.deleteActiveGameSession(session.gameId);
            }
          }
        }

        res.json({ won, prize: numericPrize, prizeValue });
      } catch (error) {
        console.error("Premio PIX reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar" });
      }
    },
  );

  // Premio Me Mimei routes
  app.post(
    "/api/games/premio-me-mimei/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { multiplier = 1, freePlay = false, useBonus = false } = req.body;
        const wallet = await storage.getWallet(req.userId);
        const baseCost = 1.00; // Base cost for Me Mimei scratch card
        const cost = (freePlay || useBonus) ? 0 : baseCost * multiplier;
        const scratchBonusCost = useBonus ? multiplier : 0; // Scratch bonus cost is multiplier

        if (!freePlay && !useBonus && (!wallet || parseFloat(wallet.balance) < cost)) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Fetch Me Mimei prizes from database
        let prizeData: any[] = [];
        try {
          const prizeProbabilities = await storage.getPrizeProbabilities('me_mimei');
          prizeData = prizeProbabilities.map(p => ({
            value: p.prize_value,
            probability: parseFloat(p.probability) // Convert string to number!
          }));
        } catch (error) {
          console.error("Error fetching Me Mimei prize probabilities, using defaults:", error);
          // Fallback to default values if database fetch fails
          prizeData = [
            { value: "0.50", probability: 28.00 },
            { value: "1.00", probability: 20.00 },
            { value: "2.00", probability: 8.00 },
            { value: "3.00", probability: 4.00 },
            { value: "4.00", probability: 2.00 },
            { value: "5.00", probability: 1.50 },
            { value: "10.00", probability: 0.80 }, // Batom Boca Rosa
            { value: "15.00", probability: 0.40 }, // M√°scara Ruby Rose
            { value: "20.00", probability: 0.30 }, // Iluminador Bruna Tavares
            { value: "50.00", probability: 0.10 }, // Perfume Egeo Dolce
            { value: "100.00", probability: 0.05 }, // Bolsa Petite Jolie
            { value: "200.00", probability: 0.02 }, // Kit WEPINK
            { value: "500.00", probability: 0.01 }, // Perfume Good Girl
            { value: "1000.00", probability: 0.005 }, // Kit Completo Bruna Tavares
            { value: "2000.00", probability: 0.002 }, // Kit Kerastase
            { value: "5000.00", probability: 0.001 }, // Bolsa Luxo Michael Kors
            { value: "10000.00", probability: 0.0002 }, // Dyson Secador
            { value: "100000.00", probability: 0.00001 } // Anel Vivara Diamante
          ];
        }

        const hiddenValues: string[] = [];

        // Check if this is the test account
        const user = await storage.getUser(req.userId);
        const isTestAccount = user?.email === "teste@gmail.com";

        // Determine if player wins based on total individual prize probabilities
        let isWinner = false;
        
        // Test account always wins
        if (isTestAccount) {
          isWinner = true;
        } else {
          // Use total probability from individual prizes as win chance
          // If total is 100%, always win. If 50%, win 50% of the time, etc.
          isWinner = Math.random() * 100 < totalWinProbability;
        }

        if (isWinner) {
          // Select winning value based on weighted probability
          const rand = Math.random() * totalWinProbability;
          let accumulator = 0;
          let winningValue = "0.50";
          
          for (const prize of prizeData) {
            accumulator += prize.probability;
            if (rand <= accumulator) {
              winningValue = prize.value;
              break;
            }
          }

          // Place winning value 3 times
          hiddenValues.push(winningValue, winningValue, winningValue);

          // Fill rest with random values (ensuring no accidental 3-match)
          const allValues = prizeData.map(p => p.value).concat(["", "", ""]);
          for (let i = 3; i < 9; i++) {
            let value;
            do {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            } while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            );
            hiddenValues.push(value);
          }
        } else {
          // Generate non-winning grid
          const allValues = prizeData.map(p => p.value).concat(["", "", "", ""]);
          for (let i = 0; i < 9; i++) {
            let value = allValues[Math.floor(Math.random() * allValues.length)];
            // Ensure no value appears 3 times
            while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            ) {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            }
            hiddenValues.push(value);
          }
        }

        // Shuffle the values
        for (let i = hiddenValues.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [hiddenValues[i], hiddenValues[j]] = [
            hiddenValues[j],
            hiddenValues[i],
          ];
        }

        // Check if user has sufficient scratch bonus when using bonus
        if (useBonus && wallet) {
          const currentScratchBonus = wallet.scratchBonus || 0;
          if (currentScratchBonus < scratchBonusCost) {
            return res.status(400).json({ error: "Raspadinhas B√¥nus insuficientes" });
          }
        }
        
        // Deduct cost or scratch bonus
        if (!freePlay && wallet) {
          if (useBonus) {
            // Deduct from scratch bonus
            const newScratchBonus = (wallet.scratchBonus || 0) - scratchBonusCost;
            await storage.updateWalletScratchBonus(req.userId, newScratchBonus);
          } else {
            // Deduct from real balance
            const newBalance = parseFloat(wallet.balance) - cost;
            await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
            await storage.incrementTotalWagered(req.userId, cost.toString());
          }
        }

        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "premio-me-mimei",
          hiddenValues,
          cost,
          multiplier, // Store multiplier to apply to prizes
          createdAt: new Date(),
        });

        res.json({ gameId, hiddenValues });
      } catch (error) {
        console.error("Premio Me Mimei create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/premio-me-mimei/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;

        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { hiddenValues, cost, multiplier = 1 } = gameState;

        // Check for winning condition
        const valueCounts = hiddenValues.reduce((acc: any, val: string) => {
          if (val && val !== "") {
            acc[val] = (acc[val] || 0) + 1;
          }
          return acc;
        }, {});

        const winningValue = Object.entries(valueCounts).find(
          ([_, count]: any) => count >= 3,
        );
        const won = !!winningValue;
        const prizeValue = won ? winningValue![0] : "";
        
        // Apply multiplier to prize
        let numericPrize = 0;
        if (won && prizeValue) {
          const basePrize = parseFloat(prizeValue) || 0;
          numericPrize = basePrize * multiplier; // Apply multiplier to prize
        }

        if (won && numericPrize > 0) {
          const wallet = await storage.getWallet(req.userId);
          if (wallet) {
            const newBalance = parseFloat(wallet.balance) + numericPrize;
            await storage.updateWalletBalance(
              req.userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Save game result to premios table
        await storage.createGamePremio({
          userId: req.userId,
          gameType: "me_mimei",
          cost: cost.toString(),
          prize: numericPrize.toString(),
          result: JSON.stringify({ gameId, hiddenValues, prizeValue }),
          won,
        });

        activeGames.delete(gameId);
        
        // Clean up active game session
        const sessions = await storage.getUserActiveGameSessions(req.userId);
        for (const session of sessions) {
          if (session.gameType === 'premio-me-mimei' && session.gameState?.gameId === gameId) {
            await storage.deleteActiveGameSession(session.gameId);
          }
        }

        res.json({ won, prize: numericPrize, prizeValue });
      } catch (error) {
        console.error("Premio Me Mimei reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar" });
      }
    },
  );

  // Premio Eletronicos routes
  app.post(
    "/api/games/premio-eletronicos/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { multiplier = 1, freePlay = false, useBonus = false } = req.body;
        const wallet = await storage.getWallet(req.userId);
        const baseCost = 1.00; // Base cost for Eletr√¥nicos scratch card
        const cost = (freePlay || useBonus) ? 0 : baseCost * multiplier;
        const scratchBonusCost = useBonus ? multiplier : 0; // Scratch bonus cost is multiplier

        if (!freePlay && !useBonus && (!wallet || parseFloat(wallet.balance) < cost)) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Fetch Eletr√¥nicos prizes from database
        let prizeData: any[] = [];
        try {
          const prizeProbabilities = await storage.getPrizeProbabilities('eletronicos');
          prizeData = prizeProbabilities.map(p => ({
            value: p.prize_value,
            probability: parseFloat(p.probability) // Convert string to number!
          }));
        } catch (error) {
          console.error("Error fetching Eletr√¥nicos prize probabilities, using defaults:", error);
          // Fallback to default values if database fetch fails
          prizeData = [
            { value: "0.50", probability: 28.00 },
            { value: "1.00", probability: 20.00 },
            { value: "2.00", probability: 8.00 },
            { value: "3.00", probability: 4.00 },
            { value: "4.00", probability: 2.00 },
            { value: "5.00", probability: 1.50 },
            { value: "10.00", probability: 0.80 }, // Cabo USB
            { value: "15.00", probability: 0.40 }, // Suporte de Celular
            { value: "20.00", probability: 0.30 }, // Capinha de Celular
            { value: "50.00", probability: 0.10 }, // Power Bank
            { value: "100.00", probability: 0.05 }, // Fone sem Fio
            { value: "200.00", probability: 0.02 }, // SmartWatch
            { value: "500.00", probability: 0.01 }, // Air Fryer
            { value: "1000.00", probability: 0.005 }, // Caixa de Som JBL
            { value: "2000.00", probability: 0.002 }, // Smart TV 55" 4K
            { value: "5000.00", probability: 0.001 }, // Notebook Dell G15
            { value: "10000.00", probability: 0.0002 }, // iPhone 16 Pro
            { value: "100000.00", probability: 0.00001 } // Kit Completo Apple
          ];
        }

        const hiddenValues: string[] = [];

        // Check if this is the test account
        const user = await storage.getUser(req.userId);
        const isTestAccount = user?.email === "teste@gmail.com";

        // Determine if player wins based on total individual prize probabilities
        let isWinner = false;
        
        // Test account always wins
        if (isTestAccount) {
          isWinner = true;
        } else {
          // Use total probability from individual prizes as win chance
          // If total is 100%, always win. If 50%, win 50% of the time, etc.
          isWinner = Math.random() * 100 < totalWinProbability;
        }

        if (isWinner) {
          // Select winning value based on weighted probability
          const rand = Math.random() * totalWinProbability;
          let accumulator = 0;
          let winningValue = "0.50";
          
          for (const prize of prizeData) {
            accumulator += prize.probability;
            if (rand <= accumulator) {
              winningValue = prize.value;
              break;
            }
          }

          // Place winning value 3 times
          hiddenValues.push(winningValue, winningValue, winningValue);

          // Fill rest with random values (ensuring no accidental 3-match)
          const allValues = prizeData.map(p => p.value).concat(["", "", ""]);
          for (let i = 3; i < 9; i++) {
            let value;
            do {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            } while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            );
            hiddenValues.push(value);
          }
        } else {
          // Generate non-winning grid
          const allValues = prizeData.map(p => p.value).concat(["", "", "", ""]);
          for (let i = 0; i < 9; i++) {
            let value = allValues[Math.floor(Math.random() * allValues.length)];
            // Ensure no value appears 3 times
            while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            ) {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            }
            hiddenValues.push(value);
          }
        }

        // Shuffle the values
        for (let i = hiddenValues.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [hiddenValues[i], hiddenValues[j]] = [
            hiddenValues[j],
            hiddenValues[i],
          ];
        }

        // Check if user has sufficient scratch bonus when using bonus
        if (useBonus && wallet) {
          const currentScratchBonus = wallet.scratchBonus || 0;
          if (currentScratchBonus < scratchBonusCost) {
            return res.status(400).json({ error: "Raspadinhas B√¥nus insuficientes" });
          }
        }
        
        // Deduct cost or scratch bonus
        if (!freePlay && wallet) {
          if (useBonus) {
            // Deduct from scratch bonus
            const newScratchBonus = (wallet.scratchBonus || 0) - scratchBonusCost;
            await storage.updateWalletScratchBonus(req.userId, newScratchBonus);
          } else {
            // Deduct from real balance
            const newBalance = parseFloat(wallet.balance) - cost;
            await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
            await storage.incrementTotalWagered(req.userId, cost.toString());
          }
        }

        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "premio-eletronicos",
          hiddenValues,
          cost,
          multiplier, // Store multiplier to apply to prizes
          createdAt: new Date(),
        });

        res.json({ gameId, hiddenValues });
      } catch (error) {
        console.error("Premio Eletronicos create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/premio-eletronicos/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;

        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { hiddenValues, cost, multiplier = 1 } = gameState;

        // Check for winning condition
        const valueCounts = hiddenValues.reduce((acc: any, val: string) => {
          if (val && val !== "") {
            acc[val] = (acc[val] || 0) + 1;
          }
          return acc;
        }, {});

        const winningValue = Object.entries(valueCounts).find(
          ([_, count]: any) => count >= 3,
        );
        const won = !!winningValue;
        const prizeValue = won ? winningValue![0] : "";
        
        // Apply multiplier to prize
        let numericPrize = 0;
        if (won && prizeValue) {
          const basePrize = parseFloat(prizeValue) || 0;
          numericPrize = basePrize * multiplier; // Apply multiplier to prize
        }

        if (won && numericPrize > 0) {
          const wallet = await storage.getWallet(req.userId);
          if (wallet) {
            const newBalance = parseFloat(wallet.balance) + numericPrize;
            await storage.updateWalletBalance(
              req.userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Save game result to premios table
        await storage.createGamePremio({
          userId: req.userId,
          gameType: "eletronicos",
          cost: cost.toString(),
          prize: numericPrize.toString(),
          result: JSON.stringify({ gameId, hiddenValues, prizeValue }),
          won,
        });

        activeGames.delete(gameId);
        
        // Clean up active game session
        const sessions = await storage.getUserActiveGameSessions(req.userId);
        for (const session of sessions) {
          if (session.gameType === 'premio-eletronicos' && session.gameState?.gameId === gameId) {
            await storage.deleteActiveGameSession(session.gameId);
          }
        }

        res.json({ won, prize: numericPrize, prizeValue });
      } catch (error) {
        console.error("Premio Eletronicos reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar" });
      }
    },
  );

  // Premio Super Premios routes
  app.post(
    "/api/games/premio-super-premios/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { multiplier = 1, freePlay = false, useBonus = false } = req.body;
        const wallet = await storage.getWallet(req.userId);
        const baseCost = 20.00; // Base cost for Super Pr√™mios scratch card
        const cost = (freePlay || useBonus) ? 0 : baseCost * multiplier;
        const scratchBonusCost = useBonus ? 20 * multiplier : 0; // Scratch bonus cost is 20 √ó multiplier

        if (!freePlay && !useBonus && (!wallet || parseFloat(wallet.balance) < cost)) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Fetch Super Pr√™mios prizes from database
        let prizeData: any[] = [];
        try {
          const prizeProbabilities = await storage.getPrizeProbabilities('super');
          prizeData = prizeProbabilities.map(p => ({
            value: p.prize_value,
            probability: parseFloat(p.probability) // Convert string to number!
          }));
        } catch (error) {
          console.error("Error fetching Super Pr√™mios prize probabilities, using defaults:", error);
          // Fallback to default values if database fetch fails
          prizeData = [
            { value: "10.00", probability: 28.00 },
            { value: "20.00", probability: 20.00 },
            { value: "40.00", probability: 10.00 },
            { value: "60.00", probability: 8.00 },
            { value: "80.00", probability: 5.00 },
            { value: "100.00", probability: 4.00 },
            { value: "200.00", probability: 2.00 }, // √ìculos
            { value: "300.00", probability: 1.50 }, // Capacete
            { value: "400.00", probability: 1.00 }, // Bicicleta
            { value: "1000.00", probability: 0.50 }, // HoverBoard
            { value: "2000.00", probability: 0.20 }, // Patinete El√©trico
            { value: "4000.00", probability: 0.08 }, // Scooter El√©trica
            { value: "10000.00", probability: 0.03 }, // Buggy
            { value: "20000.00", probability: 0.01 }, // Moto CG
            { value: "200000.00", probability: 0.001 }, // Jeep Compass
            { value: "500000.00", probability: 0.0001 } // Super Sorte
          ];
        }

        const hiddenValues: string[] = [];

        // Check if this is the test account
        const user = await storage.getUser(req.userId);
        const isTestAccount = user?.email === "teste@gmail.com";

        // Determine if player wins based on total individual prize probabilities
        let isWinner = false;
        
        // Test account always wins
        if (isTestAccount) {
          isWinner = true;
        } else {
          // Use total probability from individual prizes as win chance
          // If total is 100%, always win. If 50%, win 50% of the time, etc.
          isWinner = Math.random() * 100 < totalWinProbability;
        }

        if (isWinner) {
          // Select winning value based on weighted probability
          const rand = Math.random() * totalWinProbability;
          let accumulator = 0;
          let winningValue = "5.00";
          
          for (const prize of prizeData) {
            accumulator += prize.probability;
            if (rand <= accumulator) {
              winningValue = prize.value;
              break;
            }
          }

          // Place winning value 3 times
          hiddenValues.push(winningValue, winningValue, winningValue);

          // Fill rest with random values (ensuring no accidental 3-match)
          const allValues = prizeData.map(p => p.value).concat(["", "", ""]);
          for (let i = 3; i < 9; i++) {
            let value;
            do {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            } while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            );
            hiddenValues.push(value);
          }
        } else {
          // Generate non-winning grid
          const allValues = prizeData.map(p => p.value).concat(["", "", "", ""]);
          for (let i = 0; i < 9; i++) {
            let value = allValues[Math.floor(Math.random() * allValues.length)];
            // Ensure no value appears 3 times
            while (
              hiddenValues.filter((v) => v === value).length >= 2 &&
              value !== ""
            ) {
              value = allValues[Math.floor(Math.random() * allValues.length)];
            }
            hiddenValues.push(value);
          }
        }

        // Shuffle the values
        for (let i = hiddenValues.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [hiddenValues[i], hiddenValues[j]] = [
            hiddenValues[j],
            hiddenValues[i],
          ];
        }

        // Check if user has sufficient scratch bonus when using bonus
        if (useBonus && wallet) {
          const currentScratchBonus = wallet.scratchBonus || 0;
          if (currentScratchBonus < scratchBonusCost) {
            return res.status(400).json({ error: "Raspadinhas B√¥nus insuficientes" });
          }
        }
        
        // Deduct cost or scratch bonus
        if (!freePlay && wallet) {
          if (useBonus) {
            // Deduct from scratch bonus
            const newScratchBonus = (wallet.scratchBonus || 0) - scratchBonusCost;
            await storage.updateWalletScratchBonus(req.userId, newScratchBonus);
          } else {
            // Deduct from real balance
            const newBalance = parseFloat(wallet.balance) - cost;
            await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
            await storage.incrementTotalWagered(req.userId, cost.toString());
          }
        }

        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "premio-super-premios",
          hiddenValues,
          cost,
          multiplier, // Store multiplier to apply to prizes
          createdAt: new Date(),
        });

        res.json({ gameId, hiddenValues });
      } catch (error) {
        console.error("Premio Super Premios create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/premio-super-premios/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;

        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { hiddenValues, cost, multiplier = 1 } = gameState;

        // Check for winning condition
        const valueCounts = hiddenValues.reduce((acc: any, val: string) => {
          if (val && val !== "") {
            acc[val] = (acc[val] || 0) + 1;
          }
          return acc;
        }, {});

        const winningValue = Object.entries(valueCounts).find(
          ([_, count]: any) => count >= 3,
        );
        const won = !!winningValue;
        const prizeValue = won ? winningValue![0] : "";
        
        // Apply multiplier to prize
        let numericPrize = 0;
        if (won && prizeValue) {
          const basePrize = parseFloat(prizeValue) || 0;
          numericPrize = basePrize * multiplier; // Apply multiplier to prize
        }

        if (won && numericPrize > 0) {
          const wallet = await storage.getWallet(req.userId);
          if (wallet) {
            const newBalance = parseFloat(wallet.balance) + numericPrize;
            await storage.updateWalletBalance(
              req.userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Save game result to premios table
        await storage.createGamePremio({
          userId: req.userId,
          gameType: "super",
          cost: cost.toString(),
          prize: numericPrize.toString(),
          result: JSON.stringify({ gameId, hiddenValues, prizeValue }),
          won,
        });

        activeGames.delete(gameId);
        
        // Clean up active game session
        const sessions = await storage.getUserActiveGameSessions(req.userId);
        for (const session of sessions) {
          if (session.gameType === 'premio-super-premios' && session.gameState?.gameId === gameId) {
            await storage.deleteActiveGameSession(session.gameId);
          }
        }

        res.json({ won, prize: numericPrize, prizeValue });
      } catch (error) {
        console.error("Premio Super Premios reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar" });
      }
    },
  );

  // Raspadinha da Sorte routes (Minigame)
  app.post(
    "/api/games/sorte/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { mode = "normal" } = req.body;
        const wallet = await storage.getWallet(req.userId);

        const gameModes = {
          normal: { cost: 1, prizes: [1, 10, 100] },
          prata: { cost: 5, prizes: [5, 50, 500] },
          ouro: { cost: 20, prizes: [10, 100, 1000] },
          diamante: { cost: 100, prizes: [100, 1000, 10000] },
        };

        const config = gameModes[mode as keyof typeof gameModes];
        if (!config) {
          return res.status(400).json({ error: "Modo de jogo inv√°lido" });
        }

        if (!wallet || parseFloat(wallet.balance) < config.cost) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Generate 9 values - exactly 3 of each prize type
        const hiddenValues: string[] = [];

        // Add 3 of each prize value
        for (const prize of config.prizes) {
          for (let i = 0; i < 3; i++) {
            hiddenValues.push(`${prize}`);
          }
        }

        // Shuffle the array
        for (let i = hiddenValues.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [hiddenValues[i], hiddenValues[j]] = [
            hiddenValues[j],
            hiddenValues[i],
          ];
        }

        // Deduct cost
        const newBalance = parseFloat(wallet.balance) - config.cost;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));

        // Store game state
        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "sorte",
          cost: config.cost,
          hiddenValues,
          mode,
          createdAt: new Date(),
        });

        res.json({
          gameId,
          hiddenValues,
          cost: config.cost,
        });
      } catch (error) {
        console.error("Raspadinha da Sorte create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/sorte/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;
        const { selectedIndices, clickedIndices } = req.body;

        // Validate selected indices
        if (
          !selectedIndices ||
          !Array.isArray(selectedIndices) ||
          selectedIndices.length !== 3
        ) {
          return res
            .status(400)
            .json({ error: "√çndices selecionados inv√°lidos" });
        }

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { cost, mode, hiddenValues } = gameState;

        // Get the values at selected indices
        const selectedValues = selectedIndices.map((idx) => hiddenValues[idx]);

        // Check if all 3 selected values are the same
        const won =
          selectedValues[0] === selectedValues[1] &&
          selectedValues[1] === selectedValues[2];

        let prize = 0;
        if (won) {
          // Extract the numeric value from the string (e.g., "100" from the value)
          const prizeValue = parseInt(selectedValues[0]);
          prize = prizeValue || 0;

          // Update wallet balance
          const wallet = await storage.getWallet(req.userId);
          if (wallet && prize > 0) {
            const newBalance = parseFloat(wallet.balance) + prize;
            await storage.updateWalletBalance(
              req.userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Save game result to minigames table with complete game data
        const fullGameData = {
          revealedValues: hiddenValues,
          selectedIndices: selectedIndices,
          clickedIndices: clickedIndices || selectedIndices,
          selectedValues: selectedValues,
          mode: mode,
          cost: cost,
          prize: prize,
          won: won,
        };

        await storage.createGameMinigame({
          userId: req.userId,
          gameType: "sorte",
          cost: cost.toString(),
          prize: prize.toString(),
          result: JSON.stringify({ gameId, won, mode, selectedIndices }),
          won,
          gameData: JSON.stringify(fullGameData),
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ won, prize });
      } catch (error) {
        console.error("Raspadinha da Sorte reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar resultado" });
      }
    },
  );

  // Premio PIX Conta routes
  app.post(
    "/api/games/premio-pix-conta/create",
    authenticateToken,
    async (req: any, res) => {
      try {
        const wallet = await storage.getWallet(req.userId);
        const gameCost = 20; // Fixed cost for premio PIX conta

        if (!wallet || parseFloat(wallet.balance) < gameCost) {
          return res.status(400).json({ error: "Saldo insuficiente" });
        }

        // Define possible prize values (excluding R$ 10 and R$ 2000 as requested)
        const prizeValues = [1000, 500, 200, 100, 50, 20, 5, 2, 1, 0.5];

        // Generate 9 values for the grid
        const hiddenValues: number[] = [];

        // Determine if player wins (10% chance)
        const won = Math.random() < 0.1;
        let winningValue = 0;

        if (won) {
          // Select winning value with weighted probability (lower values more likely)
          const weights = [1, 2, 3, 5, 10, 20, 30, 40, 50, 60]; // Higher weight = more likely
          const totalWeight = weights.reduce((a, b) => a + b, 0);
          let random = Math.random() * totalWeight;
          let selectedIndex = 0;

          for (let i = 0; i < weights.length; i++) {
            random -= weights[i];
            if (random <= 0) {
              selectedIndex = i;
              break;
            }
          }

          winningValue = prizeValues[selectedIndex];

          // Place 3 matching values randomly in the grid
          const winPositions = [];
          while (winPositions.length < 3) {
            const pos = Math.floor(Math.random() * 9);
            if (!winPositions.includes(pos)) {
              winPositions.push(pos);
            }
          }

          // Fill grid
          for (let i = 0; i < 9; i++) {
            if (winPositions.includes(i)) {
              hiddenValues.push(winningValue);
            } else {
              // Add random non-winning values
              let randomValue;
              do {
                randomValue =
                  prizeValues[Math.floor(Math.random() * prizeValues.length)];
              } while (randomValue === winningValue);
              hiddenValues.push(randomValue);
            }
          }
        } else {
          // No win - ensure no 3 matching values
          for (let i = 0; i < 9; i++) {
            hiddenValues.push(
              prizeValues[Math.floor(Math.random() * prizeValues.length)],
            );
          }

          // Check and fix if accidentally created 3 matching
          const valueCounts = new Map<number, number>();
          hiddenValues.forEach((val) => {
            valueCounts.set(val, (valueCounts.get(val) || 0) + 1);
          });

          for (const [value, count] of valueCounts) {
            if (count >= 3) {
              // Replace one instance with a different value
              const index = hiddenValues.indexOf(value);
              let newValue;
              do {
                newValue =
                  prizeValues[Math.floor(Math.random() * prizeValues.length)];
              } while (newValue === value);
              hiddenValues[index] = newValue;
            }
          }
        }

        // Deduct cost
        const newBalance = parseFloat(wallet.balance) - gameCost;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));

        // Store game state
        const gameId = Math.random().toString(36).substring(7);
        activeGames.set(gameId, {
          userId: req.userId,
          type: "premio-pix-conta",
          cost: gameCost,
          hiddenValues,
          won,
          prize: winningValue,
          createdAt: new Date(),
        });

        res.json({
          gameId,
          hiddenValues,
          cost: gameCost,
        });
      } catch (error) {
        console.error("Premio PIX Conta create error:", error);
        res.status(500).json({ error: "Erro ao criar jogo" });
      }
    },
  );

  app.post(
    "/api/games/premio-pix-conta/:gameId/reveal",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;

        // Retrieve game state
        const gameState = activeGames.get(gameId);
        if (!gameState || gameState.userId !== req.userId) {
          return res.status(404).json({ error: "Jogo n√£o encontrado" });
        }

        const { won, prize, cost, hiddenValues } = gameState;

        if (won && prize > 0) {
          const wallet = await storage.getWallet(req.userId);
          if (wallet) {
            const newBalance = parseFloat(wallet.balance) + prize;
            await storage.updateWalletBalance(
              req.userId,
              newBalance.toFixed(2),
            );
          }
        }

        // Count matching values for game data
        const valueCounts = new Map<number, number>();
        hiddenValues.forEach((val: number) => {
          valueCounts.set(val, (valueCounts.get(val) || 0) + 1);
        });

        let matchingValue = null;
        let matchCount = 0;
        for (const [value, count] of valueCounts) {
          if (count >= 3) {
            matchingValue = value;
            matchCount = count;
            break;
          }
        }

        // Save game result to premios table
        await storage.createGamePremio({
          userId: req.userId,
          gameType: "pix",
          cost: cost.toString(),
          prize: prize.toString(),
          result: JSON.stringify({ gameId, won, hiddenValues }),
          won,
          gameData: JSON.stringify({
            revealedSymbols: hiddenValues.map(
              (v: number) => `R$ ${v.toFixed(2).replace(".", ",")}`,
            ),
            matchingSymbol: matchingValue
              ? `R$ ${matchingValue.toFixed(2).replace(".", ",")}`
              : null,
            matchCount,
          }),
        });

        // Clean up game state
        activeGames.delete(gameId);

        res.json({ won, prize });
      } catch (error) {
        console.error("Premio PIX Conta reveal error:", error);
        res.status(500).json({ error: "Erro ao revelar resultado" });
      }
    },
  );

  // Legacy game route
  app.post("/api/games/play", authenticateToken, async (req: any, res) => {
    try {
      const { gameType } = req.body;

      if (!gameType || !(gameType in GAME_CONFIGS)) {
        return res.status(400).json({ message: "Tipo de jogo inv√°lido" });
      }

      const config = GAME_CONFIGS[gameType as keyof typeof GAME_CONFIGS];
      const wallet = await storage.getWallet(req.userId);

      if (
        !wallet ||
        !wallet.balance ||
        parseFloat(wallet.balance) < parseFloat(config.cost)
      ) {
        return res.status(400).json({ message: "Saldo insuficiente" });
      }

      // Generate game result
      const result = generateScratchResult(
        gameType as keyof typeof GAME_CONFIGS,
      );

      // Create game record
      const game = await storage.createGame({
        userId: req.userId,
        gameType,
        cost: config.cost,
        prize: result.prize.toString(),
        result: JSON.stringify(result.grid),
        won: result.won,
      });

      // Update wallet balance
      const newBalance =
        parseFloat(wallet.balance) - parseFloat(config.cost) + result.prize;
      await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));

      res.json({
        gameId: game.id,
        result: result.grid,
        won: result.won,
        prize: result.prize,
        newBalance: newBalance.toFixed(2),
      });
    } catch (error) {
      console.error("Game play error:", error);
      res.status(500).json({ message: "Erro ao jogar" });
    }
  });

  app.get("/api/games/history", authenticateToken, async (req: any, res) => {
    try {
      // Get games from both tables
      const minigames = await storage.getGameMinigamesByUser(req.userId);
      const premios = await storage.getGamePremiosByUser(req.userId);

      // Combine and sort by playedAt date
      const allGames = [...minigames, ...premios].sort(
        (a, b) =>
          new Date(b.playedAt).getTime() - new Date(a.playedAt).getTime(),
      );

      // Limit to 100 most recent games
      const limitedGames = allGames.slice(0, 100);

      res.json(limitedGames);
    } catch (error) {
      console.error("Game history error:", error);
      res.status(500).json({ message: "Erro ao buscar hist√≥rico" });
    }
  });

  // Active game session routes
  app.get(
    "/api/games/active-sessions",
    authenticateToken,
    async (req: any, res) => {
      try {
        const sessions = await storage.getUserActiveGameSessions(req.userId);
        res.json(sessions);
      } catch (error) {
        console.error("Get active sessions error:", error);
        res.status(500).json({ error: "Erro ao buscar sess√µes ativas" });
      }
    },
  );

  app.post(
    "/api/games/save-state",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameType, gameId, gameState } = req.body;

        // Check if there's already an active session for this game type
        const existingSession = await storage.getActiveGameSession(
          req.userId,
          gameType,
        );

        if (existingSession) {
          // Update existing session
          await storage.updateActiveGameSession(
            existingSession.gameId,
            gameState,
          );
        } else {
          // Create new session
          await storage.createActiveGameSession({
            userId: req.userId,
            gameType,
            gameId,
            gameState,
          });
        }

        res.json({ success: true });
      } catch (error) {
        console.error("Save game state error:", error);
        res.status(500).json({ error: "Erro ao salvar estado do jogo" });
      }
    },
  );

  app.get(
    "/api/games/restore-state/:gameType",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameType } = req.params;
        const session = await storage.getActiveGameSession(
          req.userId,
          gameType,
        );

        if (!session) {
          return res
            .status(404)
            .json({ error: "Nenhuma sess√£o ativa encontrada" });
        }

        // Check if the game still exists in activeGames map
        const gameState = session.gameState;
        const gameId = gameState?.gameId;
        
        if (gameId && gameType.startsWith('premio-')) {
          const activeGame = activeGames.get(gameId);
          if (!activeGame || activeGame.userId !== req.userId) {
            // Game no longer exists, clean up the stale session
            await storage.deleteActiveGameSession(session.gameId);
            return res
              .status(404)
              .json({ error: "Sess√£o expirada ou jogo conclu√≠do" });
          }
        }

        res.json(session);
      } catch (error) {
        console.error("Restore game state error:", error);
        res.status(500).json({ error: "Erro ao restaurar estado do jogo" });
      }
    },
  );

  app.delete(
    "/api/games/clear-state/:gameId",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameId } = req.params;

        // Get all active sessions for the user
        const sessions = await storage.getUserActiveGameSessions(req.userId);

        for (const session of sessions) {
          // Check if the gameState is a string or object
          let gameStateObj = session.gameState;
          if (typeof gameStateObj === "string") {
            try {
              gameStateObj = JSON.parse(gameStateObj);
            } catch (e) {
              // If parsing fails, delete the session anyway
              await storage.deleteActiveGameSession(session.gameId);
              continue;
            }
          }

          // Delete if:
          // 1. The session gameId matches the requested gameId
          // 2. The gameState contains the requested gameId
          // 3. It's a premio game type (to ensure cleanup)
          if (
            session.gameId === gameId ||
            (gameStateObj && gameStateObj.gameId === gameId) ||
            (session.gameType.startsWith("premio-") &&
              gameStateObj &&
              gameStateObj.gameId === gameId)
          ) {
            await storage.deleteActiveGameSession(session.gameId);
          }
        }

        res.json({ success: true });
      } catch (error) {
        console.error("Clear game state error:", error);
        res.status(500).json({ error: "Erro ao limpar estado do jogo" });
      }
    },
  );

  // Clear all active sessions for a user
  app.delete(
    "/api/games/clear-all-sessions",
    authenticateToken,
    async (req: any, res) => {
      try {
        const sessions = await storage.getUserActiveGameSessions(req.userId);
        for (const session of sessions) {
          await storage.deleteActiveGameSession(session.gameId);
        }
        res.json({ success: true, cleared: sessions.length });
      } catch (error) {
        console.error("Clear all sessions error:", error);
        res.status(500).json({ error: "Erro ao limpar sess√µes" });
      }
    },
  );

  // Clear sessions by game type
  app.delete(
    "/api/games/clear-game-type/:gameType",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { gameType } = req.params;
        const sessions = await storage.getUserActiveGameSessions(req.userId);
        let cleared = 0;

        // Clear all sessions for this game type
        for (const session of sessions) {
          if (session.gameType === gameType) {
            await storage.deleteActiveGameSession(session.gameId);
            cleared++;
          }
        }

        // Double-check by querying again and clearing any remaining
        const remainingSessions = await storage.getUserActiveGameSessions(
          req.userId,
        );
        for (const session of remainingSessions) {
          if (session.gameType === gameType) {
            await storage.deleteActiveGameSession(session.gameId);
            cleared++;
          }
        }

        res.json({ success: true, cleared });
      } catch (error) {
        console.error("Clear game type sessions error:", error);
        res
          .status(500)
          .json({ error: "Erro ao limpar sess√µes do tipo de jogo" });
      }
    },
  );

  // Payment routes
  app.post(
    "/api/payments/create-pix",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { amount } = req.body;

        console.log("Create PIX request:", { userId: req.userId, amount });

        if (!amount || amount < 15) {
          return res.status(400).json({ message: "Valor m√≠nimo √© R$ 15,00" });
        }

        const user = await storage.getUser(req.userId);
        if (!user) {
          return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });
        }

        console.log("Creating PIX for user:", {
          id: user.id,
          name: user.name,
          email: user.email,
        });

        // Create PIX payment
        const pixResponse = await createPixPayment(amount, {
          name: user.name,
          phone: user.phone,
          email: user.email,
        });

        console.log("PIX creation response:", pixResponse);

        // Check for the new API response format
        if (!pixResponse.pixCode || !pixResponse.transactionId) {
          console.error("PIX creation failed - Invalid response:", pixResponse);
          return res
            .status(400)
            .json({ message: "Erro ao criar pagamento PIX" });
        }

        // Create deposit record
        const deposit = await storage.createDeposit({
          userId: req.userId,
          transactionId: pixResponse.transactionId,
          amount: amount.toString(),
          pixCode: pixResponse.pixCode,
          status: "pending",
        });

        res.json({
          transactionId: pixResponse.transactionId,
          qrCode: pixResponse.pixCode,
          amount: amount,
          depositId: deposit.id,
        });
      } catch (error) {
        console.error("Create PIX error:", error);
        res.status(500).json({ message: "Erro ao criar pagamento PIX" });
      }
    },
  );

  app.get(
    "/api/payments/pending-pix",
    authenticateToken,
    async (req: any, res) => {
      try {
        const deposits = await storage.getDepositsByUser(req.userId);
        const pendingDeposit = deposits.find((d) => d.status === "pending");

        if (pendingDeposit) {
          // Check if payment is older than 30 minutes
          const createdAt = new Date(pendingDeposit.createdAt);
          const now = new Date();
          const diffMinutes =
            (now.getTime() - createdAt.getTime()) / (1000 * 60);

          if (diffMinutes > 30) {
            // Expire the payment
            await storage.updateDepositStatus(
              pendingDeposit.transactionId,
              "expired",
            );
            return res.json({ hasPending: false });
          }

          return res.json({
            hasPending: true,
            pixData: {
              transactionId: pendingDeposit.transactionId,
              qrCode: pendingDeposit.pixCode,
              amount: parseFloat(pendingDeposit.amount),
              depositId: pendingDeposit.id,
              createdAt: pendingDeposit.createdAt,
            },
          });
        }

        res.json({ hasPending: false });
      } catch (error) {
        console.error("Get pending PIX error:", error);
        res.status(500).json({ message: "Erro ao buscar pagamento pendente" });
      }
    },
  );

  app.post(
    "/api/payments/cancel-pix",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { transactionId } = req.body;

        if (!transactionId) {
          return res.status(400).json({ message: "ID da transa√ß√£o requerido" });
        }

        // Update deposit status to cancelled
        await storage.updateDepositStatus(transactionId, "cancelled");

        res.json({
          status: "success",
          message: "Pagamento cancelado",
        });
      } catch (error) {
        console.error("Cancel PIX error:", error);
        res.status(500).json({ message: "Erro ao cancelar pagamento" });
      }
    },
  );

  app.post(
    "/api/payments/verify-pix",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { transactionId } = req.body;

        if (!transactionId) {
          return res.status(400).json({ message: "ID da transa√ß√£o requerido" });
        }

        // Verify payment with Checkoutinho
        const verification = await verifyPixPayment(transactionId);

        if (verification.status === "completed") {
          const deposit =
            await storage.getDepositByTransactionId(transactionId);

          if (deposit && deposit.status === "pending") {
            // Update deposit status
            await storage.updateDepositStatus(transactionId, "completed");

            // Update wallet balance
            const wallet = await storage.getWallet(deposit.userId);
            if (wallet && wallet.balance) {
              const newBalance =
                parseFloat(wallet.balance) + parseFloat(deposit.amount);
              await storage.updateWalletBalance(
                deposit.userId,
                newBalance.toFixed(2),
              );

              // Check if user has SORTE coupon and this is their first deposit
              const userDeposits = await storage.getDepositsByUserId(deposit.userId);
              const isFirstDeposit = userDeposits.filter(d => d.status === 'completed').length === 1; // This one was just completed
              const hasSOrteCoupon = sorteCouponUsers.has(deposit.userId);
              
              if (hasSOrteCoupon && isFirstDeposit) {
                // Add 100% bonus in scratch cards for SORTE coupon on first deposit
                const bonusAmount = Math.floor(parseFloat(deposit.amount));
                const currentScratchBonus = wallet.scratchBonus || 0;
                const newScratchBonus = currentScratchBonus + bonusAmount;
                await storage.updateWalletScratchBonus(deposit.userId, newScratchBonus);
                
                // Remove user from SORTE coupon list after using it
                sorteCouponUsers.delete(deposit.userId);
                console.log(`SORTE coupon bonus applied for user ${deposit.userId}: ${bonusAmount} scratch cards`);
              }
              
              // Validate referral if applicable
              await validateReferralOnDeposit(deposit.userId, deposit.amount);
              
              // Process commission for ALL deposits from referred users
              await processReferralCommission(deposit.userId, deposit.amount);

              // Get final scratch bonus after applying coupon
              const finalWallet = await storage.getWallet(deposit.userId);
              const finalScratchBonus = finalWallet?.scratchBonus || 0;
              
              res.json({
                status: "completed",
                message: "Pagamento confirmado",
                newBalance: newBalance.toFixed(2),
                scratchBonus: finalScratchBonus,
              });
            } else {
              res.json({
                status: "completed",
                message: "Pagamento confirmado",
                newBalance: parseFloat(deposit.amount).toFixed(2),
              });
            }
          } else {
            res.json({
              status: "completed",
              message: "Pagamento j√° processado",
            });
          }
        } else {
          res.json({
            status: "pending",
            message: "Pagamento ainda n√£o confirmado",
          });
        }
      } catch (error) {
        console.error("Verify PIX error:", error);
        res.status(500).json({ message: "Erro ao verificar pagamento" });
      }
    },
  );

  // Simulate successful payment (TEST ONLY)
  app.post(
    "/api/payments/simulate-success",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { transactionId } = req.body;

        if (!transactionId) {
          return res.status(400).json({ message: "ID da transa√ß√£o requerido" });
        }

        // Get the deposit
        const deposit = await storage.getDepositByTransactionId(transactionId);

        if (!deposit) {
          return res.status(404).json({ message: "Dep√≥sito n√£o encontrado" });
        }

        if (deposit.userId !== req.userId) {
          return res.status(403).json({ message: "Acesso negado" });
        }

        if (deposit.status === "completed") {
          return res.json({
            status: "already_completed",
            message: "Pagamento j√° processado",
          });
        }

        // Update deposit status to completed
        await storage.updateDepositStatus(transactionId, "completed");

        // Update wallet balance
        const wallet = await storage.getWallet(deposit.userId);
        if (wallet && wallet.balance) {
          const newBalance =
            parseFloat(wallet.balance) + parseFloat(deposit.amount);
          await storage.updateWalletBalance(
            deposit.userId,
            newBalance.toFixed(2),
          );

          // Check if user has SORTE coupon and this is their first deposit
          const userDeposits = await storage.getDepositsByUserId(deposit.userId);
          const isFirstDeposit = userDeposits.filter(d => d.status === 'completed').length === 1; // This one was just completed
          const hasSOrteCoupon = sorteCouponUsers.has(deposit.userId);
          
          if (hasSOrteCoupon && isFirstDeposit) {
            // Add 100% bonus in scratch cards for SORTE coupon on first deposit
            const bonusAmount = Math.floor(parseFloat(deposit.amount));
            const currentScratchBonus = wallet.scratchBonus || 0;
            const newScratchBonus = currentScratchBonus + bonusAmount;
            await storage.updateWalletScratchBonus(deposit.userId, newScratchBonus);
            
            // Remove user from SORTE coupon list after using it
            sorteCouponUsers.delete(deposit.userId);
            console.log(`SORTE coupon bonus applied for user ${deposit.userId}: ${bonusAmount} scratch cards`);
          }
          
          // Validate referral if applicable
          await validateReferralOnDeposit(deposit.userId, deposit.amount);
          
          // Process commission for ALL deposits from referred users
          await processReferralCommission(deposit.userId, deposit.amount);

          // Get final scratch bonus after applying coupon
          const finalWallet = await storage.getWallet(deposit.userId);
          const finalScratchBonus = finalWallet?.scratchBonus || 0;
          
          res.json({
            status: "success",
            message: "Pagamento simulado com sucesso",
            newBalance: newBalance.toFixed(2),
            scratchBonus: finalScratchBonus,
          });
        } else {
          res.json({
            status: "success",
            message: "Pagamento simulado com sucesso",
            newBalance: parseFloat(deposit.amount).toFixed(2),
          });
        }
      } catch (error) {
        console.error("Simulate payment error:", error);
        res.status(500).json({ message: "Erro ao simular pagamento" });
      }
    },
  );

  // Withdrawal routes
  // Webhook route for PIX payment notifications
  app.post("/api/webhook/pix", async (req, res) => {
    try {
      console.log("Webhook PIX received:", req.body);

      const { transactionId, status, amount } = req.body;

      if (!transactionId || !status) {
        return res.status(400).json({ message: "Dados inv√°lidos" });
      }

      if (status === "completed" || status === "paid") {
        // Get deposit info
        const deposit = await storage.getDepositByTransactionId(transactionId);

        if (deposit && deposit.status === "pending") {
          // Update deposit status
          await storage.updateDepositStatus(transactionId, "completed");

          // Update wallet balance
          const wallet = await storage.getWallet(deposit.userId);
          if (wallet && wallet.balance) {
            const newBalance =
              parseFloat(wallet.balance) + parseFloat(deposit.amount);
            await storage.updateWalletBalance(
              deposit.userId,
              newBalance.toFixed(2),
            );

            // Check if user has SORTE coupon and this is their first deposit
            const userDeposits = await storage.getDepositsByUserId(deposit.userId);
            const isFirstDeposit = userDeposits.filter(d => d.status === 'completed').length === 1; // This one was just completed
            const hasSOrteCoupon = sorteCouponUsers.has(deposit.userId);
            
            if (hasSOrteCoupon && isFirstDeposit) {
              // Add 100% bonus in scratch cards for SORTE coupon on first deposit
              const bonusAmount = Math.floor(parseFloat(deposit.amount));
              const currentScratchBonus = wallet.scratchBonus || 0;
              const newScratchBonus = currentScratchBonus + bonusAmount;
              await storage.updateWalletScratchBonus(deposit.userId, newScratchBonus);
              
              // Remove user from SORTE coupon list after using it
              sorteCouponUsers.delete(deposit.userId);
              console.log(`SORTE coupon bonus applied for user ${deposit.userId}: ${bonusAmount} scratch cards`);
            }
            
            // Validate referral if applicable
            await validateReferralOnDeposit(deposit.userId, deposit.amount);
            
            // Process commission for ALL deposits from referred users
            await processReferralCommission(deposit.userId, deposit.amount);

            console.log(
              `Webhook: Payment confirmed for user ${deposit.userId}, new balance: ${newBalance}, scratch bonus: ${newScratchBonus}`,
            );
          }
        }
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Webhook error:", error);
      res.status(500).json({ message: "Erro ao processar webhook" });
    }
  });

  app.post(
    "/api/withdrawals/request",
    authenticateToken,
    async (req: any, res) => {
      try {
        const { amount, pixKey } = req.body;

        if (!amount || amount < 10) {
          return res
            .status(400)
            .json({ message: "Valor m√≠nimo para saque √© R$ 10,00" });
        }

        const wallet = await storage.getWallet(req.userId);
        if (!wallet || !wallet.balance || parseFloat(wallet.balance) < amount) {
          return res.status(400).json({ message: "Saldo insuficiente" });
        }

        // Create withdrawal request
        const withdrawal = await storage.createWithdrawal({
          userId: req.userId,
          amount: amount.toString(),
          pixKey,
          status: "pending",
        });

        // Update wallet balance
        const newBalance = parseFloat(wallet.balance) - amount;
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));

        res.json({
          withdrawalId: withdrawal.id,
          message: "Solicita√ß√£o de saque enviada",
          newBalance: newBalance.toFixed(2),
        });
      } catch (error) {
        console.error("Withdrawal request error:", error);
        res.status(500).json({ message: "Erro ao solicitar saque" });
      }
    },
  );

  app.get(
    "/api/withdrawals/history",
    authenticateToken,
    async (req: any, res) => {
      try {
        const withdrawals = await storage.getWithdrawalsByUser(req.userId);
        res.json(withdrawals);
      } catch (error) {
        console.error("Withdrawal history error:", error);
        res.status(500).json({ message: "Erro ao buscar hist√≥rico de saques" });
      }
    },
  );

  // Admin routes
  app.post("/api/admin/login", async (req, res) => {
    try {
      const { username, password } = adminLoginSchema.parse(req.body);

      // Hardcoded admin credentials
      if (
        username !== "raspadinha45154654" ||
        password !== "GS4F4ASDF#@#$faDSA45545"
      ) {
        return res
          .status(401)
          .json({ message: "Credenciais de admin inv√°lidas" });
      }

      const sessionId = randomUUID();
      const session = await storage.createAdminSession(sessionId, username);

      res.json({
        sessionId,
        message: "Login de admin realizado com sucesso",
      });
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(400).json({ message: "Erro ao fazer login de admin" });
    }
  });

  app.post("/api/admin/logout", authenticateAdmin, async (req: any, res) => {
    try {
      await storage.deleteAdminSession(req.adminSession.sessionId);
      res.json({ message: "Logout realizado com sucesso" });
    } catch (error) {
      console.error("Admin logout error:", error);
      res.status(500).json({ message: "Erro ao fazer logout" });
    }
  });

  // Admin check auth
  app.get("/api/admin/check", async (req, res) => {
    const sessionId = req.headers.authorization?.split(" ")[1];

    if (!sessionId) {
      return res.status(401).json({ authenticated: false });
    }

    try {
      const session = await storage.getAdminSession(sessionId);
      if (session) {
        res.json({ authenticated: true, username: session.username });
      } else {
        res.status(401).json({ authenticated: false });
      }
    } catch (error) {
      console.error("Admin check error:", error);
      res.status(500).json({ authenticated: false });
    }
  });

  // Admin dashboard stats
  app.get("/api/admin/stats", authenticateAdmin, async (req, res) => {
    try {
      // Get all deposits
      const allDeposits = await storage.getDeposits();
      const completedDeposits = allDeposits.filter(
        (d) => d.status === "completed",
      );

      // Get all withdrawals
      const allWithdrawals = await storage.getWithdrawals();
      const pendingWithdrawals = allWithdrawals.filter(
        (w) => w.status === "pending",
      ).length;

      // Calculate totals
      const totalDeposits = completedDeposits.reduce(
        (sum, d) => sum + parseFloat(d.amount),
        0,
      );
      const totalWithdrawals = allWithdrawals
        .filter((w) => w.status === "completed")
        .reduce((sum, w) => sum + parseFloat(w.amount), 0);

      // Get today's data
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const todayDeposits = completedDeposits
        .filter((d) => d.completedAt && new Date(d.completedAt) >= today)
        .reduce((sum, d) => sum + parseFloat(d.amount), 0);

      const todayWithdrawals = allWithdrawals
        .filter(
          (w) =>
            w.status === "completed" &&
            w.createdAt &&
            new Date(w.createdAt) >= today,
        )
        .reduce((sum, w) => sum + parseFloat(w.amount), 0);

      // Get user stats
      const userStats = await storage.getUserStats();

      // Get scratch card stats - focus only on premio games
      const allScratchCards = await db.select().from(gamePremios);
      const todayScratchCards = allScratchCards.filter(
        (g) => g.playedAt && new Date(g.playedAt) >= today,
      );

      // Calculate scratch card specific metrics
      const pixGames = allScratchCards.filter(g => g.gameType === 'pix');
      const meMimeiGames = allScratchCards.filter(g => g.gameType === 'me_mimei');
      const eletronicosGames = allScratchCards.filter(g => g.gameType === 'eletronicos');
      const superPremiosGames = allScratchCards.filter(g => g.gameType === 'super');

      // Calculate revenue and payouts
      const scratchCardRevenue = allScratchCards.reduce(
        (sum, g) => sum + parseFloat(g.cost),
        0,
      );
      const scratchCardPayout = allScratchCards.reduce(
        (sum, g) => sum + (g.won ? parseFloat(g.prize) : 0),
        0,
      );

      // Calculate win rate
      const totalWins = allScratchCards.filter(g => g.won).length;
      const winRate = allScratchCards.length > 0 ? (totalWins / allScratchCards.length) * 100 : 0;

      // Calculate average deposit
      const avgDeposit = completedDeposits.length > 0 
        ? totalDeposits / completedDeposits.length 
        : 0;

      // Calculate average scratch card value
      const avgScratchValue = allScratchCards.length > 0 
        ? scratchCardRevenue / allScratchCards.length 
        : 0;

      // Calculate conversion rate (users who deposited / total users)
      const depositorCount = new Set(completedDeposits.map(d => d.userId)).size;
      const conversionRate = userStats.totalUsers > 0 
        ? (depositorCount / userStats.totalUsers) * 100 
        : 0;

      // Calculate retention rate (users who played in last 7 days / total users)
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const activePlayersLast7Days = new Set(
        allScratchCards
          .filter(g => g.playedAt && new Date(g.playedAt) >= sevenDaysAgo)
          .map(g => g.userId)
      ).size;
      const retentionRate = userStats.totalUsers > 0 
        ? (activePlayersLast7Days / userStats.totalUsers) * 100 
        : 0;

      // Calculate total spent on games and total prizes
      const totalSpent = scratchCardRevenue;
      const totalPrizes = scratchCardPayout;

      // Calculate profit
      const totalProfit = totalDeposits - totalWithdrawals - totalPrizes;
      const todayProfit = todayDeposits - todayWithdrawals;

      // Calculate rewards distributed (level and chest rewards)
      // This is a placeholder - in a real system you'd track this in the database
      const totalRewards = "0.00";

      res.json({
        totalUsers: userStats.totalUsers,
        activeUsers: userStats.activeUsers,
        totalDeposits: totalDeposits.toFixed(2),
        totalWithdrawals: totalWithdrawals.toFixed(2),
        totalProfit: totalProfit.toFixed(2),
        todayDeposits: todayDeposits.toFixed(2),
        todayWithdrawals: todayWithdrawals.toFixed(2),
        todayProfit: todayProfit.toFixed(2),
        pendingWithdrawals,
        totalGames: allScratchCards.length,
        todayGames: todayScratchCards.length,
        totalRewards,
        // Scratch card specific stats
        totalScratchCards: allScratchCards.length,
        todayScratchCards: todayScratchCards.length,
        scratchCardRevenue: scratchCardRevenue.toFixed(2),
        scratchCardPayout: scratchCardPayout.toFixed(2),
        pixGames: pixGames.length,
        meMimeiGames: meMimeiGames.length,
        eletronicosGames: eletronicosGames.length,
        superPremiosGames: superPremiosGames.length,
        avgScratchValue: avgScratchValue.toFixed(2),
        winRate: winRate.toFixed(2),
        retentionRate: retentionRate.toFixed(2),
        avgDeposit: avgDeposit.toFixed(2),
        conversionRate: conversionRate.toFixed(2),
      });
    } catch (error) {
      console.error("Admin stats error:", error);
      res.status(500).json({ message: "Erro ao buscar estat√≠sticas" });
    }
  });

  // Get all users
  app.get("/api/admin/users", authenticateAdmin, async (req, res) => {
    try {
      const allUsers = await db
        .select()
        .from(users)
        .orderBy(desc(users.createdAt));

      // Get wallets for all users
      const userWallets = await db.select().from(wallets);
      const walletsMap = new Map(userWallets.map((w) => [w.userId, w]));

      // Combine user data with wallet data and calculate level
      const usersWithWallets = allUsers.map((user) => {
        const wallet = walletsMap.get(user.id);
        const totalWagered = wallet?.totalWagered || "0.00";
        const level = Math.min(
          100,
          Math.floor(Math.sqrt(parseFloat(totalWagered) / 100)),
        );

        return {
          ...user,
          balance: wallet?.balance || "0.00",
          scratchBonus: wallet?.scratchBonus || 0,
          totalWagered: totalWagered,
          level: level,
          status: "active" as const, // For now, all users are active unless banned
        };
      });

      res.json(usersWithWallets);
    } catch (error) {
      console.error("Admin get users error:", error);
      res.status(500).json({ message: "Erro ao buscar usu√°rios" });
    }
  });

  // Get user details
  app.get("/api/admin/users/:userId", authenticateAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);

      // Get user deposits
      const userDeposits = await storage.getDepositsByUser(userId);
      const totalDeposited = userDeposits
        .filter((d) => d.status === "completed")
        .reduce((sum, d) => sum + parseFloat(d.amount), 0);

      // Get user games
      const userGames = await storage.getGamesByUser(userId);
      const totalWon = userGames
        .filter((g) => g.won)
        .reduce((sum, g) => sum + parseFloat(g.prize), 0);

      // Get user withdrawals
      const userWithdrawals = await storage.getWithdrawalsByUser(userId);
      const totalWithdrawn = userWithdrawals
        .filter((w) => w.status === "completed")
        .reduce((sum, w) => sum + parseFloat(w.amount), 0);

      // Get recent games
      const recentGames = userGames.slice(0, 10).map((g) => ({
        id: g.id,
        gameType: g.gameType,
        cost: g.cost,
        prize: g.prize,
        won: g.won,
        playedAt: g.playedAt,
      }));

      res.json({
        totalDeposited: totalDeposited.toFixed(2),
        totalWon: totalWon.toFixed(2),
        totalWithdrawn: totalWithdrawn.toFixed(2),
        totalGames: userGames.length,
        recentGames,
      });
    } catch (error) {
      console.error("Admin get user details error:", error);
      res.status(500).json({ message: "Erro ao buscar detalhes do usu√°rio" });
    }
  });

  // Update user balance
  app.post(
    "/api/admin/users/:userId/balance",
    authenticateAdmin,
    async (req, res) => {
      try {
        const userId = parseInt(req.params.userId);
        const { balance, scratchBonus } = req.body;

        if (!balance || isNaN(parseFloat(balance))) {
          return res.status(400).json({ message: "Saldo inv√°lido" });
        }

        await storage.updateWalletBalance(
          userId,
          parseFloat(balance).toFixed(2),
        );

        if (scratchBonus !== undefined && !isNaN(parseInt(scratchBonus))) {
          await storage.updateWalletScratchBonus(
            userId,
            parseInt(scratchBonus),
          );
        }

        res.json({ success: true, newBalance: balance });
      } catch (error) {
        console.error("Admin update balance error:", error);
        res.status(500).json({ message: "Erro ao atualizar saldo" });
      }
    },
  );

  // Ban user
  app.post(
    "/api/admin/users/:userId/ban",
    authenticateAdmin,
    async (req, res) => {
      try {
        const userId = parseInt(req.params.userId);

        // In a real system, you would add a status field to users table
        // For now, we'll just return success
        res.json({ success: true, message: "Usu√°rio banido com sucesso" });
      } catch (error) {
        console.error("Admin ban user error:", error);
        res.status(500).json({ message: "Erro ao banir usu√°rio" });
      }
    },
  );

  // Unban user
  app.post(
    "/api/admin/users/:userId/unban",
    authenticateAdmin,
    async (req, res) => {
      try {
        const userId = parseInt(req.params.userId);

        // In a real system, you would update status field to active
        res.json({ success: true, message: "Usu√°rio desbanido com sucesso" });
      } catch (error) {
        console.error("Admin unban user error:", error);
        res.status(500).json({ message: "Erro ao desbanir usu√°rio" });
      }
    },
  );

  // Get all withdrawals for admin
  app.get("/api/admin/withdrawals", authenticateAdmin, async (req, res) => {
    try {
      const allWithdrawals = await db
        .select({
          withdrawal: withdrawals,
          user: users,
        })
        .from(withdrawals)
        .leftJoin(users, eq(withdrawals.userId, users.id));

      const formattedWithdrawals = allWithdrawals.map(
        ({ withdrawal, user }) => ({
          id: withdrawal.id,
          displayId:
            withdrawal.displayId || `${withdrawal.id}`.padStart(5, "0"),
          userId: withdrawal.userId,
          userName: user?.name || "Unknown",
          userEmail: user?.email || "Unknown",
          amount: withdrawal.amount,
          pixKey: withdrawal.pixKey,
          pixKeyType: withdrawal.pixKeyType || "PIX",
          status: withdrawal.status,
          requestedAt: withdrawal.createdAt,
          processedAt: withdrawal.processedAt,
          adminNotes: withdrawal.adminNotes || null,
        }),
      );

      res.json(formattedWithdrawals);
    } catch (error) {
      console.error("Admin get withdrawals error:", error);
      res.status(500).json({ message: "Erro ao buscar saques" });
    }
  });

  // Approve withdrawal
  app.post(
    "/api/admin/withdrawals/:withdrawalId/approve",
    authenticateAdmin,
    async (req, res) => {
      try {
        const withdrawalId = parseInt(req.params.withdrawalId);
        const { adminNotes } = req.body;

        await db
          .update(withdrawals)
          .set({
            status: "approved" as any,
            processedAt: new Date().toISOString(),
            adminNotes,
          })
          .where(eq(withdrawals.id, withdrawalId));

        res.json({ success: true });
      } catch (error) {
        console.error("Admin approve withdrawal error:", error);
        res.status(500).json({ message: "Erro ao aprovar saque" });
      }
    },
  );

  // Reject withdrawal
  app.post(
    "/api/admin/withdrawals/:withdrawalId/reject",
    authenticateAdmin,
    async (req, res) => {
      try {
        const withdrawalId = parseInt(req.params.withdrawalId);
        const { adminNotes } = req.body;

        // Get withdrawal details
        const [withdrawal] = await db
          .select()
          .from(withdrawals)
          .where(eq(withdrawals.id, withdrawalId));

        if (!withdrawal) {
          return res.status(404).json({ message: "Saque n√£o encontrado" });
        }

        // Update withdrawal status
        await db
          .update(withdrawals)
          .set({
            status: "rejected" as any,
            processedAt: new Date().toISOString(),
            adminNotes,
          })
          .where(eq(withdrawals.id, withdrawalId));

        // Refund the amount to user's wallet
        const wallet = await storage.getWallet(withdrawal.userId);
        if (wallet) {
          const newBalance =
            parseFloat(wallet.balance) + parseFloat(withdrawal.amount);
          await storage.updateWalletBalance(
            withdrawal.userId,
            newBalance.toFixed(2),
          );
        }

        res.json({ success: true });
      } catch (error) {
        console.error("Admin reject withdrawal error:", error);
        res.status(500).json({ message: "Erro ao rejeitar saque" });
      }
    },
  );

  // Get all support chats for admin
  app.get("/api/admin/support/chats", authenticateAdmin, async (req, res) => {
    try {
      const allChats = await db
        .select({
          chat: supportChats,
          user: users,
        })
        .from(supportChats)
        .leftJoin(users, eq(supportChats.userId, users.id))
        .orderBy(desc(supportChats.createdAt));

      // Get messages for each chat
      const chatsWithMessages = await Promise.all(
        allChats.map(async ({ chat, user }) => {
          const messages = await db
            .select()
            .from(supportMessages)
            .where(eq(supportMessages.chatId, chat.id))
            .orderBy(asc(supportMessages.createdAt));

          return {
            id: chat.id,
            userId: chat.userId,
            userName: user?.name || "Unknown",
            userEmail: user?.email || "Unknown",
            status: chat.status,
            description: chat.description,
            createdAt: chat.createdAt,
            updatedAt: chat.updatedAt,
            messages: messages.map((msg) => ({
              id: msg.id,
              chatId: msg.chatId,
              senderId: msg.senderId,
              senderRole: msg.senderType,
              message: msg.message,
              createdAt: msg.createdAt,
            })),
          };
        }),
      );

      res.json(chatsWithMessages);
    } catch (error) {
      console.error("Admin get support chats error:", error);
      res.status(500).json({ message: "Erro ao buscar chats de suporte" });
    }
  });

  // Send admin message to support chat
  app.post(
    "/api/admin/support/send",
    authenticateAdmin,
    async (req: any, res) => {
      try {
        const { chatId, message } = req.body;

        if (!chatId || !message) {
          return res
            .status(400)
            .json({ message: "Chat ID e mensagem s√£o obrigat√≥rios" });
        }

        // Get a valid user ID for admin (using ID 1 as a placeholder for admin)
        const adminUserId = 1;

        console.log("Inserting support message:", {
          chatId,
          senderId: adminUserId,
          senderType: "admin",
          message,
        });

        const newMessage = await storage.createSupportMessage({
          chatId,
          senderId: adminUserId,
          senderType: "admin",
          message,
        });

        // Update chat's updatedAt timestamp
        // Skip the update for now to avoid the SQL error

        res.json(newMessage);
      } catch (error) {
        console.error("Admin send support message error:", error);
        res.status(500).json({ message: "Erro ao enviar mensagem" });
      }
    },
  );

  // Close support chat
  app.post(
    "/api/admin/support/close/:chatId",
    authenticateAdmin,
    async (req, res) => {
      try {
        const chatId = parseInt(req.params.chatId);

        await db
          .update(supportChats)
          .set({
            status: "closed" as any,
            updatedAt: new Date().toISOString(),
          })
          .where(eq(supportChats.id, chatId));

        res.json({ success: true });
      } catch (error) {
        console.error("Admin close support chat error:", error);
        res.status(500).json({ message: "Erro ao fechar chat" });
      }
    },
  );

  // Get all games (only scratch cards - premio games)
  app.get("/api/admin/games", authenticateAdmin, async (req, res) => {
    try {
      // Get premio games only
      const premiosData = await db
        .select({
          game: gamePremios,
          user: users,
        })
        .from(gamePremios)
        .leftJoin(users, eq(gamePremios.userId, users.id))
        .orderBy(desc(gamePremios.playedAt))
        .limit(100);

      // Format games
      const allGames = premiosData.map(({ game, user }) => ({
        id: game.id,
        displayId: game.displayId || `${game.id}`.padStart(5, "0"),
        userId: game.userId,
        userName: user?.name || "Unknown",
        userEmail: user?.email || "Unknown",
        gameType: game.gameType,
        category: "premio",
        isMinigame: false,
        cost: game.cost,
        prize: game.prize,
        won: game.won,
        result: game.result,
        playedAt: game.playedAt,
      }));

      res.json(allGames);
    } catch (error) {
      console.error("Admin get games error:", error);
      res.status(500).json({ message: "Erro ao buscar jogos" });
    }
  });

  // Get game statistics (only scratch cards - premio games)
  app.get("/api/admin/games/stats", authenticateAdmin, async (req, res) => {
    try {
      // Get all premio games only
      const allPremios = await db.select().from(gamePremios);

      // Only use premio games
      const allGames = [...allPremios];

      // Calculate statistics by game type
      const gameTypeStats: Record<string, any> = {};

      allGames.forEach((game) => {
        if (!gameTypeStats[game.gameType]) {
          gameTypeStats[game.gameType] = {
            totalGames: 0,
            totalRevenue: 0,
            totalPrizes: 0,
            totalWins: 0,
            winRate: 0,
          };
        }

        gameTypeStats[game.gameType].totalGames++;
        gameTypeStats[game.gameType].totalRevenue += parseFloat(game.cost);
        if (game.won) {
          gameTypeStats[game.gameType].totalWins++;
          gameTypeStats[game.gameType].totalPrizes += parseFloat(game.prize);
        }
      });

      // Calculate win rates
      Object.keys(gameTypeStats).forEach((gameType) => {
        const stats = gameTypeStats[gameType];
        stats.winRate =
          stats.totalGames > 0
            ? ((stats.totalWins / stats.totalGames) * 100).toFixed(2)
            : "0.00";
        stats.profit = (stats.totalRevenue - stats.totalPrizes).toFixed(2);
        stats.totalRevenue = stats.totalRevenue.toFixed(2);
        stats.totalPrizes = stats.totalPrizes.toFixed(2);
      });

      // Overall statistics
      const totalGames = allGames.length;
      const totalRevenue = allGames.reduce(
        (sum, g) => sum + parseFloat(g.cost),
        0,
      );
      const totalPrizes = allGames.reduce(
        (sum, g) => sum + (g.won ? parseFloat(g.prize) : 0),
        0,
      );
      const totalWins = allGames.filter((g) => g.won).length;
      const overallWinRate =
        totalGames > 0 ? ((totalWins / totalGames) * 100).toFixed(2) : "0.00";

      res.json({
        overall: {
          totalGames,
          totalRevenue: totalRevenue.toFixed(2),
          totalPrizes: totalPrizes.toFixed(2),
          totalWins,
          winRate: overallWinRate,
          profit: (totalRevenue - totalPrizes).toFixed(2),
        },
        byGameType: gameTypeStats,
      });
    } catch (error) {
      console.error("Admin get game stats error:", error);
      res.status(500).json({ message: "Erro ao buscar estat√≠sticas de jogos" });
    }
  });

  // Get game probabilities
  app.get("/api/admin/game-probabilities", authenticateAdmin, async (req, res) => {
    try {
      const probabilities = await storage.getGameProbabilities();
      
      // Ensure all game types have a probability entry
      const gameTypes = ['pix', 'me_mimei', 'eletronicos', 'super'];
      const existingTypes = probabilities.map(p => p.gameType);
      
      // Add default entries for missing game types
      const allProbabilities = gameTypes.map(gameType => {
        const existing = probabilities.find(p => p.gameType === gameType);
        if (existing) {
          return existing;
        }
        // Return default values for missing entries
        return {
          id: 0,
          gameType,
          winProbability: '30.00',
          forceWin: false,
          forceLose: false,
          enabled: true,
          updatedAt: new Date(),
          updatedBy: 'admin'
        };
      });
      
      res.json(allProbabilities);
    } catch (error) {
      console.error("Admin get probabilities error:", error);
      res.status(500).json({ message: "Erro ao buscar probabilidades" });
    }
  });

  // Update multiple game probabilities at once
  app.post("/api/admin/game-probabilities", authenticateAdmin, async (req, res) => {
    try {
      const { probabilities } = req.body;
      
      if (!probabilities || !Array.isArray(probabilities)) {
        return res.status(400).json({ message: "Probabilidades inv√°lidas" });
      }
      
      // Update each probability
      for (const prob of probabilities) {
        if (prob.gameType) {
          await storage.upsertGameProbability(prob.gameType, {
            winProbability: prob.winProbability?.toString(),
            forceWin: prob.forceWin || false,
            forceLose: prob.forceLose || false,
            enabled: prob.enabled !== undefined ? prob.enabled : true,
            updatedBy: 'admin'
          });
        }
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error("Admin update probabilities error:", error);
      res.status(500).json({ message: "Erro ao atualizar probabilidades" });
    }
  });

  // Update game probability
  app.post("/api/admin/probabilities/:gameType", authenticateAdmin, async (req, res) => {
    try {
      const { gameType } = req.params;
      const { winProbability, forceWin, forceLose, enabled } = req.body;
      
      // Validate game type
      const validGameTypes = ['pix', 'me_mimei', 'eletronicos', 'super'];
      if (!validGameTypes.includes(gameType)) {
        return res.status(400).json({ message: "Tipo de jogo inv√°lido" });
      }
      
      // Validate probability
      if (winProbability !== undefined) {
        const probability = parseFloat(winProbability);
        if (isNaN(probability) || probability < 0 || probability > 100) {
          return res.status(400).json({ message: "Probabilidade deve ser entre 0 e 100" });
        }
      }
      
      // Update probability
      await storage.upsertGameProbability(gameType, {
        winProbability: winProbability?.toString(),
        forceWin: forceWin || false,
        forceLose: forceLose || false,
        enabled: enabled !== undefined ? enabled : true,
        updatedBy: 'admin'
      });
      
      res.json({ success: true });
    } catch (error) {
      console.error("Admin update probability error:", error);
      res.status(500).json({ message: "Erro ao atualizar probabilidade" });
    }
  });

  // Get prize probabilities for a specific game
  app.get("/api/admin/prize-probabilities/:gameType", authenticateAdmin, async (req, res) => {
    try {
      const { gameType } = req.params;
      
      // Validate game type
      const validGameTypes = ['pix', 'me_mimei', 'eletronicos', 'super'];
      if (!validGameTypes.includes(gameType)) {
        return res.status(400).json({ message: "Tipo de jogo inv√°lido" });
      }
      
      const probabilities = await storage.getPrizeProbabilities(gameType);
      res.json(probabilities);
    } catch (error) {
      console.error("Admin get prize probabilities error:", error);
      res.status(500).json({ message: "Erro ao buscar probabilidades de pr√™mios" });
    }
  });

  // Get all prize probabilities
  app.get("/api/admin/prize-probabilities", authenticateAdmin, async (req, res) => {
    try {
      const probabilities = await storage.getAllPrizeProbabilities();
      res.json(probabilities);
    } catch (error) {
      console.error("Admin get all prize probabilities error:", error);
      res.status(500).json({ message: "Erro ao buscar probabilidades de pr√™mios" });
    }
  });

  // Update prize probabilities for a specific game
  app.post("/api/admin/prize-probabilities/:gameType", authenticateAdmin, async (req, res) => {
    try {
      const { gameType } = req.params;
      const { prizes } = req.body;
      
      // Validate game type
      const validGameTypes = ['pix', 'me_mimei', 'eletronicos', 'super'];
      if (!validGameTypes.includes(gameType)) {
        return res.status(400).json({ message: "Tipo de jogo inv√°lido" });
      }
      
      // Validate prizes array
      if (!prizes || !Array.isArray(prizes)) {
        return res.status(400).json({ message: "Lista de pr√™mios inv√°lida" });
      }
      
      // Validate total probability is not greater than 100%
      const totalProbability = prizes.reduce((sum, prize) => sum + parseFloat(prize.probability || 0), 0);
      if (totalProbability > 100.01) {
        return res.status(400).json({ 
          message: `A soma das probabilidades n√£o pode exceder 100%. Total atual: ${totalProbability.toFixed(4)}%` 
        });
      }
      
      // Update prize probabilities
      await storage.updatePrizeProbabilities(gameType, prizes);
      
      res.json({ success: true });
    } catch (error) {
      console.error("Admin update prize probabilities error:", error);
      res.status(500).json({ message: "Erro ao atualizar probabilidades de pr√™mios" });
    }
  });

  // Get all transactions
  app.get("/api/admin/transactions", authenticateAdmin, async (req, res) => {
    try {
      // Get deposits
      const depositsData = await db
        .select({
          id: deposits.id,
          userId: deposits.userId,
          userName: users.name,
          amount: deposits.amount,
          status: deposits.status,
          createdAt: deposits.createdAt,
        })
        .from(deposits)
        .leftJoin(users, eq(deposits.userId, users.id))
        .orderBy(desc(deposits.createdAt))
        .limit(50);

      // Get withdrawals
      const withdrawalsData = await db
        .select({
          id: withdrawals.id,
          userId: withdrawals.userId,
          userName: users.name,
          amount: withdrawals.amount,
          status: withdrawals.status,
          createdAt: withdrawals.createdAt,
        })
        .from(withdrawals)
        .leftJoin(users, eq(withdrawals.userId, users.id))
        .orderBy(desc(withdrawals.createdAt))
        .limit(50);

      // Combine and format transactions
      const transactions = [
        ...depositsData.map((d) => ({
          id: d.id,
          userId: d.userId,
          userName: d.userName || "Unknown",
          type: "deposit",
          amount: d.amount,
          status: d.status,
          createdAt: d.createdAt,
          details: {},
        })),
        ...withdrawalsData.map((w) => ({
          id: w.id,
          userId: w.userId,
          userName: w.userName || "Unknown",
          type: "withdrawal",
          amount: w.amount,
          status: w.status,
          createdAt: w.createdAt,
          details: {},
        })),
      ].sort(
        (a, b) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
      );

      res.json(transactions);
    } catch (error) {
      console.error("Admin get transactions error:", error);
      res.status(500).json({ message: "Erro ao buscar transa√ß√µes" });
    }
  });

  // Get all deposits for admin
  app.get("/api/admin/deposits", authenticateAdmin, async (req, res) => {
    try {
      const allDeposits = await db
        .select({
          deposit: deposits,
          user: users,
        })
        .from(deposits)
        .leftJoin(users, eq(deposits.userId, users.id))
        .orderBy(desc(deposits.createdAt));

      const formattedDeposits = allDeposits.map(({ deposit, user }) => ({
        id: deposit.id,
        displayId: deposit.displayId || deposit.transactionId,
        userId: deposit.userId,
        userName: user?.name || "Unknown",
        userEmail: user?.email || "Unknown",
        amount: deposit.amount,
        status: deposit.status,
        pixCode: deposit.pixCode,
        transactionId: deposit.transactionId,
        createdAt: deposit.createdAt,
        completedAt: deposit.completedAt,
      }));

      res.json(formattedDeposits);
    } catch (error) {
      console.error("Admin get deposits error:", error);
      res.status(500).json({ message: "Erro ao buscar dep√≥sitos" });
    }
  });

  // Get deposit statistics
  app.get("/api/admin/deposits/stats", authenticateAdmin, async (req, res) => {
    try {
      const allDeposits = await db.select().from(deposits);

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const thisMonth = new Date(today.getFullYear(), today.getMonth(), 1);

      const stats = {
        total: {
          count: 0,
          amount: 0,
          completed: 0,
          pending: 0,
          cancelled: 0,
        },
        today: {
          count: 0,
          amount: 0,
        },
        thisMonth: {
          count: 0,
          amount: 0,
        },
      };

      allDeposits.forEach((deposit) => {
        stats.total.count++;

        if (deposit.status === "completed") {
          stats.total.completed++;
          stats.total.amount += parseFloat(deposit.amount);

          const createdDate = new Date(deposit.createdAt);

          if (createdDate >= today) {
            stats.today.count++;
            stats.today.amount += parseFloat(deposit.amount);
          }

          if (createdDate >= thisMonth) {
            stats.thisMonth.count++;
            stats.thisMonth.amount += parseFloat(deposit.amount);
          }
        } else if (deposit.status === "pending") {
          stats.total.pending++;
        } else if (
          deposit.status === "cancelled" ||
          deposit.status === "expired"
        ) {
          stats.total.cancelled++;
        }
      });

      // Calculate pending amount
      let pendingAmount = 0;
      allDeposits.forEach((deposit) => {
        if (deposit.status === "pending") {
          pendingAmount += parseFloat(deposit.amount);
        }
      });

      res.json({
        totalDeposits: stats.total.completed,
        totalAmount: stats.total.amount.toFixed(2),
        todayDeposits: stats.today.count,
        todayAmount: stats.today.amount.toFixed(2),
        pendingCount: stats.total.pending,
        pendingAmount: pendingAmount.toFixed(2),
      });
    } catch (error) {
      console.error("Admin get deposit stats error:", error);
      res
        .status(500)
        .json({ message: "Erro ao buscar estat√≠sticas de dep√≥sitos" });
    }
  });

  // Admin Bonus Code Routes
  app.get("/api/admin/bonus-codes/usage", authenticateAdmin, async (req, res) => {
    try {
      // Since we store bonus code usage in memory, we need to track it differently
      // For now, return empty array as this would need a proper database table to track usage
      const bonusUsages: any[] = [];
      
      // In a real implementation, you would have a bonus_code_usage table
      // that tracks userId, code, amount, and timestamp
      
      res.json(bonusUsages);
    } catch (error) {
      console.error("Admin get bonus codes usage error:", error);
      res.status(500).json({ message: "Erro ao buscar uso de c√≥digos b√¥nus" });
    }
  });

  app.get("/api/admin/bonus-codes/stats", authenticateAdmin, async (req, res) => {
    try {
      // Since we store bonus code usage in memory, these are placeholder stats
      // In a real implementation, you would calculate from the database
      
      const stats = {
        totalUsages: 0,
        totalBonusAwarded: 0,
        todayUsages: 0,
        uniqueUsers: 0,
      };
      
      res.json(stats);
    } catch (error) {
      console.error("Admin get bonus codes stats error:", error);
      res.status(500).json({ message: "Erro ao buscar estat√≠sticas de c√≥digos b√¥nus" });
    }
  });

  // Rewards routes
  app.get("/api/rewards/status", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.userId;
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Check if user has ever made a deposit
      // Alternative: check if user has balance > 0
      const wallet = await storage.getWallet(userId);
      const hasBalance = wallet && parseFloat(wallet.balance) > 0;

      // Also check deposits
      const deposits = await storage.getDepositsByUser(userId);
      const hasCompletedDeposit = deposits.some(
        (d) => d.status === "completed",
      );

      // User has ever deposited if they have balance OR completed deposits
      const hasEverDeposited = hasBalance || hasCompletedDeposit;

      // Check if daily chest was already claimed today
      const claimedToday = userDailyChestClaims.get(userId);
      const canClaimDailyChest =
        hasEverDeposited &&
        (!claimedToday ||
          new Date(claimedToday).toDateString() !== today.toDateString());

      // Get claimed rewards from user data or storage
      const claimedLevelRewards = userClaimedRewards.get(userId) || [];

      res.json({
        canClaimDailyChest,
        hasEverDeposited,
        claimedLevelRewards,
      });
    } catch (error) {
      console.error("Rewards status error:", error);
      res.status(500).json({ error: "Erro ao buscar status de recompensas" });
    }
  });

  // Daily spin routes
  app.get(
    "/api/daily-spin/status",
    authenticateToken,
    async (req: any, res) => {
      try {
        const canSpin = await storage.canSpinToday(req.userId);
        const lastSpin = await storage.getLastDailySpin(req.userId);

        res.json({
          canSpin,
          lastSpin: lastSpin
            ? {
                amount: lastSpin.amount,
                spunAt: lastSpin.spinDate,
              }
            : null,
        });
      } catch (error) {
        console.error("Daily spin status error:", error);
        res.status(500).json({ error: "Erro ao verificar status do giro" });
      }
    },
  );

  app.post("/api/daily-spin/spin", authenticateToken, async (req: any, res) => {
    try {
      // Check if user can spin today
      const canSpin = await storage.canSpinToday(req.userId);
      if (!canSpin) {
        return res
          .status(400)
          .json({ error: "Voc√™ j√° girou hoje. Volte amanh√£!" });
      }

      // Define prizes and probabilities
      // Money: R$1: 40%, R$2: 20%, R$5: 10%, R$10: 5%
      // Scratch cards: PIX kit: 10%, Me Mimei kit: 8%, Eletr√¥nicos kit: 5%, Super kit: 2%
      const random = Math.random() * 100;
      let prizeType: "money" | "scratch_cards";
      let amount: number = 0;
      let scratchType: string = "";
      
      if (random < 40) {
        prizeType = "money";
        amount = 1;
      } else if (random < 60) {
        prizeType = "money";
        amount = 2;
      } else if (random < 70) {
        prizeType = "money";
        amount = 5;
      } else if (random < 75) {
        prizeType = "money";
        amount = 10;
      } else if (random < 85) {
        prizeType = "scratch_cards";
        scratchType = "pix_kit";
      } else if (random < 93) {
        prizeType = "scratch_cards";
        scratchType = "me_mimei_kit";
      } else if (random < 98) {
        prizeType = "scratch_cards";
        scratchType = "eletronicos_kit";
      } else {
        prizeType = "scratch_cards";
        scratchType = "super_kit";
      }

      // Save spin record
      await storage.createDailySpin({
        userId: req.userId,
        amount: prizeType === "money" ? amount.toFixed(2) : "0",
        prizeType: prizeType,
        scratchType: scratchType || undefined,
      });

      // Handle prize based on type
      if (prizeType === "money") {
        // Convert money to scratch bonus (1 real = 1 scratch)
        const wallet = await storage.getWallet(req.userId);
        if (wallet) {
          const scratchTickets = Math.floor(amount); // Convert reais to scratch tickets
          const newScratchBonus = (wallet.scratchBonus || 0) + scratchTickets;
          await storage.updateWalletScratchBonus(req.userId, newScratchBonus);
        }
        
        res.json({
          success: true,
          type: "money",
          amount,
          message: `Voc√™ ganhou ${Math.floor(amount)} raspadinha${Math.floor(amount) > 1 ? 's' : ''} b√¥nus!`,
        });
      } else {
        // Scratch cards prize
        const gameMap: Record<string, string> = {
          "pix_kit": "3 Raspadinhas PIX",
          "me_mimei_kit": "3 Raspadinhas Me Mimei",
          "eletronicos_kit": "3 Raspadinhas Eletr√¥nicos",
          "super_kit": "3 Raspadinhas Super Pr√™mios"
        };
        
        res.json({
          success: true,
          type: "scratch_cards",
          scratchType,
          message: `Voc√™ ganhou ${gameMap[scratchType]}!`,
        });
      }
    } catch (error) {
      console.error("Daily spin error:", error);
      res.status(500).json({ error: "Erro ao processar giro" });
    }
  });

  app.post(
    "/api/rewards/claim-chest",
    authenticateToken,
    async (req: any, res) => {
      try {
        const userId = req.userId;
        const today = new Date();
        const { rewardType, scratchCards } = req.body;

        // Check if already claimed today
        const lastClaim = userDailyChestClaims.get(userId);
        if (
          lastClaim &&
          new Date(lastClaim).toDateString() === today.toDateString()
        ) {
          return res.status(400).json({ error: "Ba√∫ j√° resgatado hoje" });
        }

        // Check if user has ever made a deposit or has balance
        const wallet = await storage.getWallet(userId);
        const hasBalance = wallet && parseFloat(wallet.balance) > 0;
        const deposits = await storage.getDepositsByUser(userId);
        const hasEverDeposited =
          hasBalance || deposits.some((d) => d.status === "completed");

        if (!hasEverDeposited) {
          return res
            .status(400)
            .json({
              error: "Fa√ßa seu primeiro dep√≥sito para desbloquear o ba√∫ di√°rio",
            });
        }

        // Process reward based on type
        let rewardValue = 0;

        if (
          rewardType &&
          rewardType.includes("Raspadinha") &&
          scratchCards > 0
        ) {
          // Give scratch cards as balance (R$1 per scratch card for PIX, R$2 for Me Mimei)
          if (rewardType === "Raspadinha PIX") {
            rewardValue = scratchCards * 1;
          } else if (rewardType === "Raspadinha Me Mimei") {
            rewardValue = scratchCards * 2;
          }

          // Add scratch card value to balance
          if (wallet && rewardValue > 0) {
            const newBalance = parseFloat(wallet.balance) + rewardValue;
            await storage.updateWalletBalance(userId, newBalance.toFixed(2));
          }
        }

        // Mark as claimed today
        userDailyChestClaims.set(userId, today);

        res.json({
          reward: rewardValue,
          type: rewardType,
          scratchCards: scratchCards || 0,
        });
      } catch (error) {
        console.error("Claim chest error:", error);
        res.status(500).json({ error: "Erro ao resgatar ba√∫" });
      }
    },
  );

  app.post(
    "/api/rewards/claim-level",
    authenticateToken,
    async (req: any, res) => {
      try {
        const userId = req.userId;
        const { level } = req.body;

        if (!level || typeof level !== "number") {
          return res.status(400).json({ error: "N√≠vel inv√°lido" });
        }

        // Calculate user's current level based on XP
        const games = await storage.getGamesByUser(userId);
        const totalXP = games.length * 10; // 10 XP per game
        const currentLevel = Math.floor(totalXP / 100) + 1; // 100 XP per level

        if (currentLevel < level) {
          return res
            .status(400)
            .json({ error: "Voc√™ ainda n√£o alcan√ßou este n√≠vel" });
        }

        // Get user's claimed rewards
        let claimedRewards = userClaimedRewards.get(userId) || [];

        if (claimedRewards.includes(level)) {
          return res.status(400).json({ error: "Recompensa j√° resgatada" });
        }

        // Define level rewards
        const levelRewards: { [key: number]: number } = {
          5: 10,
          10: 25,
          15: 50,
          20: 75,
          25: 100,
          30: 150,
          40: 200,
          50: 300,
          75: 500,
          100: 1000,
        };

        const rewardAmount = levelRewards[level];
        if (!rewardAmount) {
          return res
            .status(400)
            .json({ error: "N√≠vel de recompensa inv√°lido" });
        }

        // Add reward to user's balance
        const wallet = await storage.getWallet(userId);
        if (wallet) {
          const newBalance = parseFloat(wallet.balance) + rewardAmount;
          await storage.updateWalletBalance(userId, newBalance.toFixed(2));
        }

        // Mark as claimed
        claimedRewards.push(level);
        userClaimedRewards.set(userId, claimedRewards);

        res.json({ reward: rewardAmount });
      } catch (error) {
        console.error("Claim level reward error:", error);
        res.status(500).json({ error: "Erro ao resgatar recompensa" });
      }
    },
  );

  // Bonus Code Routes
  app.post("/api/bonus/claim", authenticateOptionalWithWelcome, async (req: any, res) => {
    try {
      const { code } = req.body;
      const userId = req.userId;
      
      if (!code) {
        return res.status(400).json({ message: "C√≥digo √© obrigat√≥rio" });
      }
      
      // Check if code is valid
      if (code.toUpperCase() !== "SORTE100") {
        return res.status(400).json({ message: "C√≥digo inv√°lido" });
      }
      
      // Check if user already used this code
      const hasUsed = await storage.hasUsedBonusCode(userId || 0, code.toUpperCase());
      if (hasUsed) {
        return res.status(400).json({ message: "Voc√™ j√° utilizou este c√≥digo" });
      }
      
      // Award 100 scratch bonus
      const amount = 100;
      
      if (userId) {
        // For logged in users, add to their bonus
        const wallet = await storage.getWallet(userId);
        if (wallet) {
          await storage.updateWalletScratchBonus(userId, wallet.scratchBonus + amount);
        }
        
        // Mark code as used
        await storage.markBonusCodeAsUsed(userId, code.toUpperCase());
      }
      
      res.json({ success: true, amount });
    } catch (error) {
      console.error("Bonus claim error:", error);
      res.status(500).json({ message: "Erro ao resgatar c√≥digo" });
    }
  });

  // Support Chat Routes

  // Get active chat
  app.get(
    "/api/support/active-chat",
    authenticateToken,
    async (req: any, res) => {
      const userId = req.userId;
      const activeChat = await storage.getUserActiveChat(userId);

      if (!activeChat) {
        return res.status(404).json({ message: "Nenhum chamado ativo" });
      }

      res.json(activeChat);
    },
  );

  // Get chat details with messages
  app.get(
    "/api/support/chat/:chatId",
    authenticateToken,
    async (req: any, res) => {
      const userId = req.userId;
      const chatId = parseInt(req.params.chatId);

      const chat = await storage.getSupportChat(chatId);
      if (!chat || chat.userId !== userId) {
        return res.status(403).json({ message: "Chat n√£o encontrado" });
      }

      const messages = await storage.getChatMessages(chatId);
      res.json({ chat, messages });
    },
  );

  // Create new support chat
  app.post("/api/support/create", authenticateToken, async (req: any, res) => {
    const userId = req.userId;
    const { description } = req.body;

    if (!description || !description.trim()) {
      return res.status(400).json({ message: "Descri√ß√£o √© obrigat√≥ria" });
    }

    // Check if user already has active chat
    const existingChat = await storage.getUserActiveChat(userId);
    if (existingChat) {
      return res
        .status(400)
        .json({ message: "Voc√™ j√° possui um chamado ativo" });
    }

    // Create new chat
    const chat = await storage.createSupportChat(userId);

    // Send automatic welcome message
    await storage.createSupportMessage({
      chatId: chat.id,
      senderId: 0,
      senderType: "system",
      message:
        "Ol√°! Bem-vindo ao suporte. Um atendente responder√° em instantes.",
    });

    // Send user's description as first message
    await storage.createSupportMessage({
      chatId: chat.id,
      senderId: userId,
      senderType: "user",
      message: description,
    });

    res.json(chat);
  });

  app.post("/api/support/send", authenticateToken, async (req: any, res) => {
    const userId = req.userId;
    const { chatId, message } = req.body;

    if (!chatId || !message) {
      return res
        .status(400)
        .json({ message: "Chat ID e mensagem s√£o obrigat√≥rios" });
    }

    // Verify chat belongs to user
    const chat = await storage.getSupportChat(chatId);
    if (!chat || chat.userId !== userId) {
      return res.status(403).json({ message: "Chat n√£o encontrado" });
    }

    if (chat.status !== "active") {
      return res.status(400).json({ message: "Este chat est√° fechado" });
    }

    // Create message
    const newMessage = await storage.createSupportMessage({
      chatId,
      senderId: userId,
      senderType: "user",
      message,
    });

    res.json(newMessage);
  });

  app.post("/api/support/close", authenticateToken, async (req: any, res) => {
    const userId = req.userId;
    const { chatId } = req.body;

    if (!chatId) {
      return res.status(400).json({ message: "Chat ID √© obrigat√≥rio" });
    }

    // Verify chat belongs to user
    const chat = await storage.getSupportChat(chatId);
    if (!chat || chat.userId !== userId) {
      return res.status(403).json({ message: "Chat n√£o encontrado" });
    }

    await storage.closeSupportChat(chatId, "user");

    res.json({ message: "Chat fechado com sucesso" });
  });

  // Admin Support Routes
  app.get("/api/admin/support/chats", authenticateAdmin, async (req, res) => {
    const activeChats = await storage.getActiveSupportChats();
    res.json(activeChats);
  });

  app.get(
    "/api/admin/support/chat/:chatId",
    authenticateAdmin,
    async (req, res) => {
      const chatId = parseInt(req.params.chatId);
      const chat = await storage.getSupportChat(chatId);

      if (!chat) {
        return res.status(404).json({ message: "Chat n√£o encontrado" });
      }

      const messages = await storage.getChatMessages(chatId);
      const user = await storage.getUser(chat.userId);

      res.json({ chat, messages, user });
    },
  );

  app.post(
    "/api/admin/support/send",
    authenticateAdmin,
    async (req: any, res) => {
      const adminId = req.adminSession.adminId;
      const { chatId, message } = req.body;

      if (!chatId || !message) {
        return res
          .status(400)
          .json({ message: "Chat ID e mensagem s√£o obrigat√≥rios" });
      }

      const chat = await storage.getSupportChat(chatId);
      if (!chat) {
        return res.status(404).json({ message: "Chat n√£o encontrado" });
      }

      const newMessage = await storage.createSupportMessage({
        chatId,
        senderId: adminId,
        senderType: "admin",
        message,
      });

      res.json(newMessage);
    },
  );

  app.post("/api/admin/support/close", authenticateAdmin, async (req, res) => {
    const { chatId } = req.body;

    if (!chatId) {
      return res.status(400).json({ message: "Chat ID √© obrigat√≥rio" });
    }

    await storage.closeSupportChat(chatId, "admin");

    res.json({ message: "Chat fechado com sucesso" });
  });

  // Referral routes
  app.get("/api/referrals/my-code", authenticateToken, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.userId);
      if (!user) {
        return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });
      }
      
      res.json({ referralCode: user.referralCode });
    } catch (error) {
      console.error("Get referral code error:", error);
      res.status(500).json({ message: "Erro ao buscar c√≥digo de indica√ß√£o" });
    }
  });
  
  app.post("/api/referrals/validate", async (req, res) => {
    try {
      const { referralCode } = req.body;
      
      if (!referralCode) {
        return res.status(400).json({ message: "C√≥digo de indica√ß√£o √© obrigat√≥rio" });
      }
      
      // Convert to uppercase to handle case-insensitive validation
      const normalizedCode = referralCode.toUpperCase();
      
      // Special handling for system codes
      if (normalizedCode === 'SORTE100') {
        res.json({ valid: true, referrerName: 'Promo√ß√£o Especial' });
        return;
      }
      
      // Special handling for BONUS code
      if (normalizedCode === 'BONUS') {
        res.json({ valid: true, referrerName: 'C√≥digo de B√¥nus' });
        return;
      }
      
      const referrer = await storage.getUserByReferralCode(normalizedCode);
      if (!referrer) {
        return res.status(404).json({ message: "C√≥digo de indica√ß√£o inv√°lido" });
      }
      
      res.json({ valid: true, referrerName: referrer.name });
    } catch (error) {
      console.error("Validate referral code error:", error);
      res.status(500).json({ message: "Erro ao validar c√≥digo de indica√ß√£o" });
    }
  });
  
  app.get("/api/referrals/stats", authenticateToken, async (req: any, res) => {
    try {
      const referrals = await storage.getReferralsByReferrer(req.userId);
      const totalEarnings = await storage.getReferralEarningsTotal(req.userId);
      const availableEarnings = await storage.getReferralEarningsAvailable(req.userId);
      
      res.json({
        totalReferrals: referrals.length,
        validatedReferrals: referrals.filter(r => r.status === 'validated').length,
        totalEarnings,
        availableEarnings
      });
    } catch (error) {
      console.error("Get referral stats error:", error);
      res.status(500).json({ message: "Erro ao buscar estat√≠sticas de indica√ß√£o" });
    }
  });
  
  app.get("/api/referrals/list", authenticateToken, async (req: any, res) => {
    try {
      const referrals = await storage.getReferralsByReferrer(req.userId);
      
      // Get user details for each referral
      const referralsWithDetails = await Promise.all(
        referrals.map(async (referral) => {
          const user = await storage.getUser(referral.referredId);
          return {
            id: referral.id,
            name: user?.name || "Usu√°rio",
            email: user?.email || "",
            status: referral.status,
            createdAt: referral.createdAt,
            validatedAt: referral.validatedAt
          };
        })
      );
      
      res.json(referralsWithDetails);
    } catch (error) {
      console.error("Get referrals list error:", error);
      res.status(500).json({ message: "Erro ao buscar lista de indicados" });
    }
  });
  
  app.get("/api/referrals/earnings", authenticateToken, async (req: any, res) => {
    try {
      const earnings = await storage.getReferralEarnings(req.userId);
      res.json(earnings);
    } catch (error) {
      console.error("Get referral earnings error:", error);
      res.status(500).json({ message: "Erro ao buscar ganhos de indica√ß√£o" });
    }
  });
  
  app.get("/api/referrals/transactions", authenticateToken, async (req: any, res) => {
    try {
      // Get all earnings (deposits)
      const earnings = await storage.getReferralEarnings(req.userId);
      
      // Format earnings as transactions
      const transactions = earnings.map(earning => ({
        id: earning.id,
        type: earning.withdrawn ? 'withdrawal' : 'deposit',
        amount: earning.amount,
        description: earning.withdrawn ? 'Saque' : 'Dep√≥sito',
        status: earning.withdrawn ? 'completed' : 'available',
        createdAt: earning.withdrawn && earning.withdrawnAt ? earning.withdrawnAt : earning.createdAt
      }));
      
      // Sort by date descending
      transactions.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
      
      res.json(transactions);
    } catch (error) {
      console.error("Get referral transactions error:", error);
      res.status(500).json({ message: "Erro ao buscar hist√≥rico de transa√ß√µes" });
    }
  });
  


  app.post("/api/referrals/withdraw", authenticateToken, async (req: any, res) => {
    try {
      const { amount } = req.body;
      
      if (!amount || parseFloat(amount) < 50) {
        return res.status(400).json({ message: "Valor m√≠nimo para saque √© R$ 50,00" });
      }
      
      const availableEarnings = await storage.getReferralEarningsAvailable(req.userId);
      console.log(`Available earnings before withdrawal: ${availableEarnings}`);
      
      if (parseFloat(amount) > parseFloat(availableEarnings)) {
        return res.status(400).json({ message: "Saldo insuficiente" });
      }
      
      // Mark earnings as withdrawn
      await storage.withdrawReferralEarnings(req.userId, amount);
      
      // Check available earnings after withdrawal
      const newAvailableEarnings = await storage.getReferralEarningsAvailable(req.userId);
      console.log(`Available earnings after withdrawal: ${newAvailableEarnings}`);
      
      // Add the amount to user's wallet balance
      const wallet = await storage.getWallet(req.userId);
      if (wallet) {
        const newBalance = parseFloat(wallet.balance) + parseFloat(amount);
        await storage.updateWalletBalance(req.userId, newBalance.toFixed(2));
      }
      
      res.json({ 
        success: true, 
        message: "Saldo transferido para sua carteira com sucesso!" 
      });
    } catch (error) {
      console.error("Withdraw referral earnings error:", error);
      res.status(500).json({ message: "Erro ao transferir saldo para carteira" });
    }
  });

  // Test endpoint for game probabilities
  app.get("/api/test/game-probabilities", async (req, res) => {
    try {
      const result = await db.select().from(gameProbabilities);
      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error("Test game probabilities error:", error);
      res.status(500).json({ error: error.message, stack: error.stack });
    }
  });

  // Support Agent Routes
  app.post("/api/support-agent/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      // Fixed credentials as requested
      if (username === "macaco" && password === "123") {
        const token = jwt.sign(
          { agentId: "macaco", role: "support-agent" },
          JWT_SECRET,
          { expiresIn: "24h" }
        );
        
        res.json({
          success: true,
          token,
          name: "Atendente"
        });
      } else {
        res.status(401).json({ error: "Credenciais inv√°lidas" });
      }
    } catch (error) {
      console.error("Support agent login error:", error);
      res.status(500).json({ error: "Erro ao fazer login" });
    }
  });

  // Middleware to verify support agent token
  const authenticateSupportAgent = async (req: any, res: any, next: any) => {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(" ")[1];

    if (!token) {
      return res.status(401).json({ message: "Token de acesso requerido" });
    }

    try {
      const decoded = jwt.verify(token, JWT_SECRET) as { agentId: string; role: string };
      if (decoded.role !== "support-agent") {
        return res.status(403).json({ message: "Acesso negado" });
      }
      req.agentId = decoded.agentId;
      next();
    } catch (error) {
      return res.status(403).json({ message: "Token inv√°lido" });
    }
  };

  // Get open support chats for agents
  app.get("/api/support-agent/chats", authenticateSupportAgent, async (req, res) => {
    try {
      const chats = await storage.getOpenSupportChats();
      
      // Transform chats to include user names and messages
      const chatsWithDetails = await Promise.all(
        chats.map(async (chat) => {
          const user = await storage.getUserById(chat.userId);
          const messages = await storage.getSupportChatMessages(chat.id);
          
          // Get the first user message as the subject
          const firstUserMessage = messages.find(msg => msg.senderType === 'user');
          const subject = firstUserMessage ? firstUserMessage.message : "Sem assunto";
          
          return {
            id: chat.id,
            userId: chat.userId,
            userName: user?.name || "Usu√°rio",
            subject: subject,
            status: chat.status,
            messages: messages.map(msg => ({
              id: msg.id,
              content: msg.message,
              sender: msg.senderType,
              createdAt: msg.createdAt
            })),
            createdAt: chat.createdAt
          };
        })
      );
      
      res.json(chatsWithDetails);
    } catch (error) {
      console.error("Get support chats error:", error);
      res.status(500).json({ message: "Erro ao buscar chamados" });
    }
  });

  // Send message as support agent
  app.post("/api/support-agent/send", authenticateSupportAgent, async (req, res) => {
    try {
      const { chatId, content } = req.body;
      
      if (!content) {
        return res.status(400).json({ message: "Mensagem √© obrigat√≥ria" });
      }
      
      // Using a fixed admin user ID (1) for support agents
      const message = await storage.createSupportMessage({
        chatId,
        senderId: 1, // Fixed admin user ID
        senderType: "admin",
        message: content
      });
      
      res.json({ success: true, message });
    } catch (error) {
      console.error("Send support message error:", error);
      res.status(500).json({ message: "Erro ao enviar mensagem" });
    }
  });

  // Close support chat
  app.post("/api/support-agent/close/:id", authenticateSupportAgent, async (req, res) => {
    try {
      const chatId = parseInt(req.params.id);
      
      await storage.closeSupportChat(chatId);
      
      res.json({ success: true, message: "Chamado finalizado com sucesso" });
    } catch (error) {
      console.error("Close support chat error:", error);
      res.status(500).json({ message: "Erro ao finalizar chamado" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
